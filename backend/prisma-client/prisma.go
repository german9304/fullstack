
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"

  

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = "http://prisma:4466/fullstackapp/posts"
var Secret          = ""


      func (client *Client) Comment (params CommentWhereUniqueInput) *CommentExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"CommentWhereUniqueInput!", "Comment"},
          "comment",
          []string{"id","body","createdAt","updatedAt"})

        return &CommentExec{ret}
      }

      type CommentsParams struct {
        Where *CommentWhereInput `json:"where,omitempty"`
OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Comments (params *CommentsParams) *CommentExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
          "comments",
          []string{"id","body","createdAt","updatedAt"})

        return &CommentExecArray{ret}
      }

      type CommentsConnectionParams struct {
        Where *CommentWhereInput `json:"where,omitempty"`
OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *CommentConnection) Nodes() []Comment {
        var nodes []Comment
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *CommentConnection) NodesPtr() []*Comment {
        var nodes []*Comment
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) CommentsConnection (params *CommentsConnectionParams) (*CommentConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
          "commentsConnection",
          []string{"edges", "pageInfo"})

        return &CommentConnectionExec{ret}
      }

      func (client *Client) LikeComment (params LikeCommentWhereUniqueInput) *LikeCommentExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"LikeCommentWhereUniqueInput!", "LikeComment"},
          "likeComment",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikeCommentExec{ret}
      }

      type LikeCommentsParams struct {
        Where *LikeCommentWhereInput `json:"where,omitempty"`
OrderBy *LikeCommentOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) LikeComments (params *LikeCommentsParams) *LikeCommentExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LikeCommentWhereInput", "LikeCommentOrderByInput", "LikeComment"},
          "likeComments",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikeCommentExecArray{ret}
      }

      type LikeCommentsConnectionParams struct {
        Where *LikeCommentWhereInput `json:"where,omitempty"`
OrderBy *LikeCommentOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *LikeCommentConnection) Nodes() []LikeComment {
        var nodes []LikeComment
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *LikeCommentConnection) NodesPtr() []*LikeComment {
        var nodes []*LikeComment
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) LikeCommentsConnection (params *LikeCommentsConnectionParams) (*LikeCommentConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LikeCommentWhereInput", "LikeCommentOrderByInput", "LikeComment"},
          "likeCommentsConnection",
          []string{"edges", "pageInfo"})

        return &LikeCommentConnectionExec{ret}
      }

      func (client *Client) LikePost (params LikePostWhereUniqueInput) *LikePostExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"LikePostWhereUniqueInput!", "LikePost"},
          "likePost",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikePostExec{ret}
      }

      type LikePostsParams struct {
        Where *LikePostWhereInput `json:"where,omitempty"`
OrderBy *LikePostOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) LikePosts (params *LikePostsParams) *LikePostExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LikePostWhereInput", "LikePostOrderByInput", "LikePost"},
          "likePosts",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikePostExecArray{ret}
      }

      type LikePostsConnectionParams struct {
        Where *LikePostWhereInput `json:"where,omitempty"`
OrderBy *LikePostOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *LikePostConnection) Nodes() []LikePost {
        var nodes []LikePost
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *LikePostConnection) NodesPtr() []*LikePost {
        var nodes []*LikePost
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) LikePostsConnection (params *LikePostsConnectionParams) (*LikePostConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LikePostWhereInput", "LikePostOrderByInput", "LikePost"},
          "likePostsConnection",
          []string{"edges", "pageInfo"})

        return &LikePostConnectionExec{ret}
      }

      func (client *Client) Post (params PostWhereUniqueInput) *PostExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"PostWhereUniqueInput!", "Post"},
          "post",
          []string{"id","header","body","picture","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      type PostsParams struct {
        Where *PostWhereInput `json:"where,omitempty"`
OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Posts (params *PostsParams) *PostExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"PostWhereInput", "PostOrderByInput", "Post"},
          "posts",
          []string{"id","header","body","picture","createdAt","updatedAt"})

        return &PostExecArray{ret}
      }

      type PostsConnectionParams struct {
        Where *PostWhereInput `json:"where,omitempty"`
OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *PostConnection) Nodes() []Post {
        var nodes []Post
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *PostConnection) NodesPtr() []*Post {
        var nodes []*Post
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) PostsConnection (params *PostsConnectionParams) (*PostConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"PostWhereInput", "PostOrderByInput", "Post"},
          "postsConnection",
          []string{"edges", "pageInfo"})

        return &PostConnectionExec{ret}
      }

      func (client *Client) User (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "user",
          []string{"id","email","name","password","createdAt"})

        return &UserExec{ret}
      }

      type UsersParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Users (params *UsersParams) *UserExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "users",
          []string{"id","email","name","password","createdAt"})

        return &UserExecArray{ret}
      }

      type UsersConnectionParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *UserConnection) Nodes() []User {
        var nodes []User
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *UserConnection) NodesPtr() []*User {
        var nodes []*User
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) UsersConnection (params *UsersConnectionParams) (*UserConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "usersConnection",
          []string{"edges", "pageInfo"})

        return &UserConnectionExec{ret}
      }



      func (client *Client) CreateComment (params CommentCreateInput) *CommentExec {
        ret := client.Client.Create(
          params,
          [2]string{"CommentCreateInput!", "Comment"},
          "createComment",
          []string{"id","body","createdAt","updatedAt"})

        return &CommentExec{ret}
      }

      type CommentUpdateParams struct {
        Data CommentUpdateInput `json:"data"`
Where CommentWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateComment (params CommentUpdateParams) *CommentExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"CommentUpdateInput!", "CommentWhereUniqueInput!", "Comment"},
                 "updateComment",
                 []string{"id","body","createdAt","updatedAt"})

        return &CommentExec{ret}
      }

      type CommentUpdateManyParams struct {
        Data CommentUpdateManyMutationInput `json:"data"`
Where *CommentWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyComments (params CommentUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"CommentUpdateManyMutationInput!", "CommentWhereInput"},
          "updateManyComments")
        return &BatchPayloadExec{exec}
      }

      type CommentUpsertParams struct {
        Where CommentWhereUniqueInput `json:"where"`
Create CommentCreateInput `json:"create"`
Update CommentUpdateInput `json:"update"`
      }
      func (client *Client) UpsertComment (params CommentUpsertParams) *CommentExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"CommentWhereUniqueInput!", "CommentCreateInput!", "CommentUpdateInput!","Comment"},
          "upsertComment",
          []string{"id","body","createdAt","updatedAt"})

        return &CommentExec{ret}
      }

      func (client *Client) DeleteComment (params CommentWhereUniqueInput) *CommentExec {
        ret := client.Client.Delete(
          params,
          [2]string{"CommentWhereUniqueInput!", "Comment"},
          "deleteComment",
          []string{"id","body","createdAt","updatedAt"})

        return &CommentExec{ret}
      }

      func (client *Client) DeleteManyComments (params *CommentWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "CommentWhereInput", "deleteManyComments")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateLikeComment (params LikeCommentCreateInput) *LikeCommentExec {
        ret := client.Client.Create(
          params,
          [2]string{"LikeCommentCreateInput!", "LikeComment"},
          "createLikeComment",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikeCommentExec{ret}
      }

      type LikeCommentUpdateParams struct {
        Data LikeCommentUpdateInput `json:"data"`
Where LikeCommentWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateLikeComment (params LikeCommentUpdateParams) *LikeCommentExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"LikeCommentUpdateInput!", "LikeCommentWhereUniqueInput!", "LikeComment"},
                 "updateLikeComment",
                 []string{"id","createdAt","updatedAt","quantity"})

        return &LikeCommentExec{ret}
      }

      type LikeCommentUpdateManyParams struct {
        Data LikeCommentUpdateManyMutationInput `json:"data"`
Where *LikeCommentWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyLikeComments (params LikeCommentUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"LikeCommentUpdateManyMutationInput!", "LikeCommentWhereInput"},
          "updateManyLikeComments")
        return &BatchPayloadExec{exec}
      }

      type LikeCommentUpsertParams struct {
        Where LikeCommentWhereUniqueInput `json:"where"`
Create LikeCommentCreateInput `json:"create"`
Update LikeCommentUpdateInput `json:"update"`
      }
      func (client *Client) UpsertLikeComment (params LikeCommentUpsertParams) *LikeCommentExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"LikeCommentWhereUniqueInput!", "LikeCommentCreateInput!", "LikeCommentUpdateInput!","LikeComment"},
          "upsertLikeComment",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikeCommentExec{ret}
      }

      func (client *Client) DeleteLikeComment (params LikeCommentWhereUniqueInput) *LikeCommentExec {
        ret := client.Client.Delete(
          params,
          [2]string{"LikeCommentWhereUniqueInput!", "LikeComment"},
          "deleteLikeComment",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikeCommentExec{ret}
      }

      func (client *Client) DeleteManyLikeComments (params *LikeCommentWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "LikeCommentWhereInput", "deleteManyLikeComments")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateLikePost (params LikePostCreateInput) *LikePostExec {
        ret := client.Client.Create(
          params,
          [2]string{"LikePostCreateInput!", "LikePost"},
          "createLikePost",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikePostExec{ret}
      }

      type LikePostUpdateParams struct {
        Data LikePostUpdateInput `json:"data"`
Where LikePostWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateLikePost (params LikePostUpdateParams) *LikePostExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"LikePostUpdateInput!", "LikePostWhereUniqueInput!", "LikePost"},
                 "updateLikePost",
                 []string{"id","createdAt","updatedAt","quantity"})

        return &LikePostExec{ret}
      }

      type LikePostUpdateManyParams struct {
        Data LikePostUpdateManyMutationInput `json:"data"`
Where *LikePostWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyLikePosts (params LikePostUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"LikePostUpdateManyMutationInput!", "LikePostWhereInput"},
          "updateManyLikePosts")
        return &BatchPayloadExec{exec}
      }

      type LikePostUpsertParams struct {
        Where LikePostWhereUniqueInput `json:"where"`
Create LikePostCreateInput `json:"create"`
Update LikePostUpdateInput `json:"update"`
      }
      func (client *Client) UpsertLikePost (params LikePostUpsertParams) *LikePostExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"LikePostWhereUniqueInput!", "LikePostCreateInput!", "LikePostUpdateInput!","LikePost"},
          "upsertLikePost",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikePostExec{ret}
      }

      func (client *Client) DeleteLikePost (params LikePostWhereUniqueInput) *LikePostExec {
        ret := client.Client.Delete(
          params,
          [2]string{"LikePostWhereUniqueInput!", "LikePost"},
          "deleteLikePost",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikePostExec{ret}
      }

      func (client *Client) DeleteManyLikePosts (params *LikePostWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "LikePostWhereInput", "deleteManyLikePosts")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreatePost (params PostCreateInput) *PostExec {
        ret := client.Client.Create(
          params,
          [2]string{"PostCreateInput!", "Post"},
          "createPost",
          []string{"id","header","body","picture","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      type PostUpdateParams struct {
        Data PostUpdateInput `json:"data"`
Where PostWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdatePost (params PostUpdateParams) *PostExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"PostUpdateInput!", "PostWhereUniqueInput!", "Post"},
                 "updatePost",
                 []string{"id","header","body","picture","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      type PostUpdateManyParams struct {
        Data PostUpdateManyMutationInput `json:"data"`
Where *PostWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyPosts (params PostUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"PostUpdateManyMutationInput!", "PostWhereInput"},
          "updateManyPosts")
        return &BatchPayloadExec{exec}
      }

      type PostUpsertParams struct {
        Where PostWhereUniqueInput `json:"where"`
Create PostCreateInput `json:"create"`
Update PostUpdateInput `json:"update"`
      }
      func (client *Client) UpsertPost (params PostUpsertParams) *PostExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"PostWhereUniqueInput!", "PostCreateInput!", "PostUpdateInput!","Post"},
          "upsertPost",
          []string{"id","header","body","picture","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      func (client *Client) DeletePost (params PostWhereUniqueInput) *PostExec {
        ret := client.Client.Delete(
          params,
          [2]string{"PostWhereUniqueInput!", "Post"},
          "deletePost",
          []string{"id","header","body","picture","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      func (client *Client) DeleteManyPosts (params *PostWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "PostWhereInput", "deleteManyPosts")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateUser (params UserCreateInput) *UserExec {
        ret := client.Client.Create(
          params,
          [2]string{"UserCreateInput!", "User"},
          "createUser",
          []string{"id","email","name","password","createdAt"})

        return &UserExec{ret}
      }

      type UserUpdateParams struct {
        Data UserUpdateInput `json:"data"`
Where UserWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateUser (params UserUpdateParams) *UserExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
                 "updateUser",
                 []string{"id","email","name","password","createdAt"})

        return &UserExec{ret}
      }

      type UserUpdateManyParams struct {
        Data UserUpdateManyMutationInput `json:"data"`
Where *UserWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyUsers (params UserUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
          "updateManyUsers")
        return &BatchPayloadExec{exec}
      }

      type UserUpsertParams struct {
        Where UserWhereUniqueInput `json:"where"`
Create UserCreateInput `json:"create"`
Update UserUpdateInput `json:"update"`
      }
      func (client *Client) UpsertUser (params UserUpsertParams) *UserExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!","User"},
          "upsertUser",
          []string{"id","email","name","password","createdAt"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteUser (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.Delete(
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "deleteUser",
          []string{"id","email","name","password","createdAt"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteManyUsers (params *UserWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
        return &BatchPayloadExec{exec}
      }


        type PostOrderByInput string
        const (
          PostOrderByInputIDAsc PostOrderByInput = "id_ASC"
PostOrderByInputIDDesc PostOrderByInput = "id_DESC"
PostOrderByInputHeaderAsc PostOrderByInput = "header_ASC"
PostOrderByInputHeaderDesc PostOrderByInput = "header_DESC"
PostOrderByInputBodyAsc PostOrderByInput = "body_ASC"
PostOrderByInputBodyDesc PostOrderByInput = "body_DESC"
PostOrderByInputPictureAsc PostOrderByInput = "picture_ASC"
PostOrderByInputPictureDesc PostOrderByInput = "picture_DESC"
PostOrderByInputCreatedAtAsc PostOrderByInput = "createdAt_ASC"
PostOrderByInputCreatedAtDesc PostOrderByInput = "createdAt_DESC"
PostOrderByInputUpdatedAtAsc PostOrderByInput = "updatedAt_ASC"
PostOrderByInputUpdatedAtDesc PostOrderByInput = "updatedAt_DESC"
          )

        type CommentOrderByInput string
        const (
          CommentOrderByInputIDAsc CommentOrderByInput = "id_ASC"
CommentOrderByInputIDDesc CommentOrderByInput = "id_DESC"
CommentOrderByInputBodyAsc CommentOrderByInput = "body_ASC"
CommentOrderByInputBodyDesc CommentOrderByInput = "body_DESC"
CommentOrderByInputCreatedAtAsc CommentOrderByInput = "createdAt_ASC"
CommentOrderByInputCreatedAtDesc CommentOrderByInput = "createdAt_DESC"
CommentOrderByInputUpdatedAtAsc CommentOrderByInput = "updatedAt_ASC"
CommentOrderByInputUpdatedAtDesc CommentOrderByInput = "updatedAt_DESC"
          )

        type LikePostOrderByInput string
        const (
          LikePostOrderByInputIDAsc LikePostOrderByInput = "id_ASC"
LikePostOrderByInputIDDesc LikePostOrderByInput = "id_DESC"
LikePostOrderByInputCreatedAtAsc LikePostOrderByInput = "createdAt_ASC"
LikePostOrderByInputCreatedAtDesc LikePostOrderByInput = "createdAt_DESC"
LikePostOrderByInputUpdatedAtAsc LikePostOrderByInput = "updatedAt_ASC"
LikePostOrderByInputUpdatedAtDesc LikePostOrderByInput = "updatedAt_DESC"
LikePostOrderByInputQuantityAsc LikePostOrderByInput = "quantity_ASC"
LikePostOrderByInputQuantityDesc LikePostOrderByInput = "quantity_DESC"
          )

        type LikeCommentOrderByInput string
        const (
          LikeCommentOrderByInputIDAsc LikeCommentOrderByInput = "id_ASC"
LikeCommentOrderByInputIDDesc LikeCommentOrderByInput = "id_DESC"
LikeCommentOrderByInputCreatedAtAsc LikeCommentOrderByInput = "createdAt_ASC"
LikeCommentOrderByInputCreatedAtDesc LikeCommentOrderByInput = "createdAt_DESC"
LikeCommentOrderByInputUpdatedAtAsc LikeCommentOrderByInput = "updatedAt_ASC"
LikeCommentOrderByInputUpdatedAtDesc LikeCommentOrderByInput = "updatedAt_DESC"
LikeCommentOrderByInputQuantityAsc LikeCommentOrderByInput = "quantity_ASC"
LikeCommentOrderByInputQuantityDesc LikeCommentOrderByInput = "quantity_DESC"
          )

        type UserOrderByInput string
        const (
          UserOrderByInputIDAsc UserOrderByInput = "id_ASC"
UserOrderByInputIDDesc UserOrderByInput = "id_DESC"
UserOrderByInputEmailAsc UserOrderByInput = "email_ASC"
UserOrderByInputEmailDesc UserOrderByInput = "email_DESC"
UserOrderByInputNameAsc UserOrderByInput = "name_ASC"
UserOrderByInputNameDesc UserOrderByInput = "name_DESC"
UserOrderByInputPasswordAsc UserOrderByInput = "password_ASC"
UserOrderByInputPasswordDesc UserOrderByInput = "password_DESC"
UserOrderByInputCreatedAtAsc UserOrderByInput = "createdAt_ASC"
UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

      type LikeCommentUpdateWithoutCommentDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
User *UserUpdateOneRequiredWithoutCommentLikesInput `json:"user,omitempty"`
          }

      type CommentWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type CommentUpdateWithWhereUniqueWithoutAuthorInput struct {
        Where CommentWhereUniqueInput `json:"where"`
Data CommentUpdateWithoutAuthorDataInput `json:"data"`
          }

      type CommentWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Body *string `json:"body,omitempty"`
BodyNot *string `json:"body_not,omitempty"`
BodyIn []string `json:"body_in,omitempty"`
BodyNotIn []string `json:"body_not_in,omitempty"`
BodyLt *string `json:"body_lt,omitempty"`
BodyLte *string `json:"body_lte,omitempty"`
BodyGt *string `json:"body_gt,omitempty"`
BodyGte *string `json:"body_gte,omitempty"`
BodyContains *string `json:"body_contains,omitempty"`
BodyNotContains *string `json:"body_not_contains,omitempty"`
BodyStartsWith *string `json:"body_starts_with,omitempty"`
BodyNotStartsWith *string `json:"body_not_starts_with,omitempty"`
BodyEndsWith *string `json:"body_ends_with,omitempty"`
BodyNotEndsWith *string `json:"body_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Author *UserWhereInput `json:"author,omitempty"`
Post *PostWhereInput `json:"post,omitempty"`
LikesEvery *LikeCommentWhereInput `json:"likes_every,omitempty"`
LikesSome *LikeCommentWhereInput `json:"likes_some,omitempty"`
LikesNone *LikeCommentWhereInput `json:"likes_none,omitempty"`
And []CommentWhereInput `json:"AND,omitempty"`
Or []CommentWhereInput `json:"OR,omitempty"`
Not []CommentWhereInput `json:"NOT,omitempty"`
          }

      type UserCreateOneWithoutPostLikesInput struct {
        Create *UserCreateWithoutPostLikesInput `json:"create,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikeCommentUpsertWithWhereUniqueWithoutCommentInput struct {
        Where LikeCommentWhereUniqueInput `json:"where"`
Update LikeCommentUpdateWithoutCommentDataInput `json:"update"`
Create LikeCommentCreateWithoutCommentInput `json:"create"`
          }

      type UserCreateWithoutPostLikesInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
Comments *CommentCreateManyWithoutAuthorInput `json:"comments,omitempty"`
CommentLikes *LikeCommentCreateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type CommentUpdateWithoutAuthorDataInput struct {
        Body *string `json:"body,omitempty"`
Post *PostUpdateOneRequiredWithoutCommentsInput `json:"post,omitempty"`
Likes *LikeCommentUpdateManyWithoutCommentInput `json:"likes,omitempty"`
          }

      type CommentUpdateInput struct {
        Body *string `json:"body,omitempty"`
Author *UserUpdateOneRequiredWithoutCommentsInput `json:"author,omitempty"`
Post *PostUpdateOneRequiredWithoutCommentsInput `json:"post,omitempty"`
Likes *LikeCommentUpdateManyWithoutCommentInput `json:"likes,omitempty"`
          }

      type UserSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *UserWhereInput `json:"node,omitempty"`
And []UserSubscriptionWhereInput `json:"AND,omitempty"`
Or []UserSubscriptionWhereInput `json:"OR,omitempty"`
Not []UserSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type UserUpdateOneRequiredWithoutCommentsInput struct {
        Create *UserCreateWithoutCommentsInput `json:"create,omitempty"`
Update *UserUpdateWithoutCommentsDataInput `json:"update,omitempty"`
Upsert *UserUpsertWithoutCommentsInput `json:"upsert,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *PostWhereInput `json:"node,omitempty"`
And []PostSubscriptionWhereInput `json:"AND,omitempty"`
Or []PostSubscriptionWhereInput `json:"OR,omitempty"`
Not []PostSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type UserUpdateWithoutCommentsDataInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
PostLikes *LikePostUpdateManyWithoutUserInput `json:"postLikes,omitempty"`
CommentLikes *LikeCommentUpdateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type LikeCommentSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *LikeCommentWhereInput `json:"node,omitempty"`
And []LikeCommentSubscriptionWhereInput `json:"AND,omitempty"`
Or []LikeCommentSubscriptionWhereInput `json:"OR,omitempty"`
Not []LikeCommentSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type PostUpdateManyWithoutAuthorInput struct {
        Create []PostCreateWithoutAuthorInput `json:"create,omitempty"`
Delete []PostWhereUniqueInput `json:"delete,omitempty"`
Connect []PostWhereUniqueInput `json:"connect,omitempty"`
Set []PostWhereUniqueInput `json:"set,omitempty"`
Disconnect []PostWhereUniqueInput `json:"disconnect,omitempty"`
Update []PostUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
Upsert []PostUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
DeleteMany []PostScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []PostUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type UserUpdateManyMutationInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
          }

      type PostUpdateWithWhereUniqueWithoutAuthorInput struct {
        Where PostWhereUniqueInput `json:"where"`
Data PostUpdateWithoutAuthorDataInput `json:"data"`
          }

      type UserCreateInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
Comments *CommentCreateManyWithoutAuthorInput `json:"comments,omitempty"`
PostLikes *LikePostCreateManyWithoutUserInput `json:"postLikes,omitempty"`
CommentLikes *LikeCommentCreateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type PostUpdateWithoutAuthorDataInput struct {
        Header *string `json:"header,omitempty"`
Body *string `json:"body,omitempty"`
Picture *string `json:"picture,omitempty"`
Comments *CommentUpdateManyWithoutPostInput `json:"comments,omitempty"`
Likes *LikePostUpdateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type PostUpdateInput struct {
        Header *string `json:"header,omitempty"`
Body *string `json:"body,omitempty"`
Picture *string `json:"picture,omitempty"`
Author *UserUpdateOneRequiredWithoutPostsInput `json:"author,omitempty"`
Comments *CommentUpdateManyWithoutPostInput `json:"comments,omitempty"`
Likes *LikePostUpdateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type CommentUpdateManyWithoutPostInput struct {
        Create []CommentCreateWithoutPostInput `json:"create,omitempty"`
Delete []CommentWhereUniqueInput `json:"delete,omitempty"`
Connect []CommentWhereUniqueInput `json:"connect,omitempty"`
Set []CommentWhereUniqueInput `json:"set,omitempty"`
Disconnect []CommentWhereUniqueInput `json:"disconnect,omitempty"`
Update []CommentUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
Upsert []CommentUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
DeleteMany []CommentScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []CommentUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type PostCreateInput struct {
        ID *string `json:"id,omitempty"`
Header string `json:"header"`
Body string `json:"body"`
Picture *string `json:"picture,omitempty"`
Author UserCreateOneWithoutPostsInput `json:"author"`
Comments *CommentCreateManyWithoutPostInput `json:"comments,omitempty"`
Likes *LikePostCreateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type CommentUpdateWithWhereUniqueWithoutPostInput struct {
        Where CommentWhereUniqueInput `json:"where"`
Data CommentUpdateWithoutPostDataInput `json:"data"`
          }

      type LikePostUpdateInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
User *UserUpdateOneRequiredWithoutPostLikesInput `json:"user,omitempty"`
Post *PostUpdateOneRequiredWithoutLikesInput `json:"post,omitempty"`
          }

      type CommentUpdateWithoutPostDataInput struct {
        Body *string `json:"body,omitempty"`
Author *UserUpdateOneRequiredWithoutCommentsInput `json:"author,omitempty"`
Likes *LikeCommentUpdateManyWithoutCommentInput `json:"likes,omitempty"`
          }

      type LikePostCreateInput struct {
        ID *string `json:"id,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
User UserCreateOneWithoutPostLikesInput `json:"user"`
Post PostCreateOneWithoutLikesInput `json:"post"`
          }

      type LikeCommentUpdateManyWithoutCommentInput struct {
        Create []LikeCommentCreateWithoutCommentInput `json:"create,omitempty"`
Delete []LikeCommentWhereUniqueInput `json:"delete,omitempty"`
Connect []LikeCommentWhereUniqueInput `json:"connect,omitempty"`
Set []LikeCommentWhereUniqueInput `json:"set,omitempty"`
Disconnect []LikeCommentWhereUniqueInput `json:"disconnect,omitempty"`
Update []LikeCommentUpdateWithWhereUniqueWithoutCommentInput `json:"update,omitempty"`
Upsert []LikeCommentUpsertWithWhereUniqueWithoutCommentInput `json:"upsert,omitempty"`
DeleteMany []LikeCommentScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []LikeCommentUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type LikeCommentUpdateInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
User *UserUpdateOneRequiredWithoutCommentLikesInput `json:"user,omitempty"`
Comment *CommentUpdateOneRequiredWithoutLikesInput `json:"comment,omitempty"`
          }

      type LikeCommentUpdateWithWhereUniqueWithoutCommentInput struct {
        Where LikeCommentWhereUniqueInput `json:"where"`
Data LikeCommentUpdateWithoutCommentDataInput `json:"data"`
          }

      type LikeCommentCreateInput struct {
        ID *string `json:"id,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
User UserCreateOneWithoutCommentLikesInput `json:"user"`
Comment CommentCreateOneWithoutLikesInput `json:"comment"`
          }

      type CommentUpsertWithWhereUniqueWithoutPostInput struct {
        Where CommentWhereUniqueInput `json:"where"`
Update CommentUpdateWithoutPostDataInput `json:"update"`
Create CommentCreateWithoutPostInput `json:"create"`
          }

      type UserUpsertWithoutCommentsInput struct {
        Update UserUpdateWithoutCommentsDataInput `json:"update"`
Create UserCreateWithoutCommentsInput `json:"create"`
          }

      type UserUpdateOneRequiredWithoutCommentLikesInput struct {
        Create *UserCreateWithoutCommentLikesInput `json:"create,omitempty"`
Update *UserUpdateWithoutCommentLikesDataInput `json:"update,omitempty"`
Upsert *UserUpsertWithoutCommentLikesInput `json:"upsert,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpdateManyDataInput struct {
        Header *string `json:"header,omitempty"`
Body *string `json:"body,omitempty"`
Picture *string `json:"picture,omitempty"`
          }

      type UserUpdateWithoutCommentLikesDataInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
Comments *CommentUpdateManyWithoutAuthorInput `json:"comments,omitempty"`
PostLikes *LikePostUpdateManyWithoutUserInput `json:"postLikes,omitempty"`
          }

      type PostScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Header *string `json:"header,omitempty"`
HeaderNot *string `json:"header_not,omitempty"`
HeaderIn []string `json:"header_in,omitempty"`
HeaderNotIn []string `json:"header_not_in,omitempty"`
HeaderLt *string `json:"header_lt,omitempty"`
HeaderLte *string `json:"header_lte,omitempty"`
HeaderGt *string `json:"header_gt,omitempty"`
HeaderGte *string `json:"header_gte,omitempty"`
HeaderContains *string `json:"header_contains,omitempty"`
HeaderNotContains *string `json:"header_not_contains,omitempty"`
HeaderStartsWith *string `json:"header_starts_with,omitempty"`
HeaderNotStartsWith *string `json:"header_not_starts_with,omitempty"`
HeaderEndsWith *string `json:"header_ends_with,omitempty"`
HeaderNotEndsWith *string `json:"header_not_ends_with,omitempty"`
Body *string `json:"body,omitempty"`
BodyNot *string `json:"body_not,omitempty"`
BodyIn []string `json:"body_in,omitempty"`
BodyNotIn []string `json:"body_not_in,omitempty"`
BodyLt *string `json:"body_lt,omitempty"`
BodyLte *string `json:"body_lte,omitempty"`
BodyGt *string `json:"body_gt,omitempty"`
BodyGte *string `json:"body_gte,omitempty"`
BodyContains *string `json:"body_contains,omitempty"`
BodyNotContains *string `json:"body_not_contains,omitempty"`
BodyStartsWith *string `json:"body_starts_with,omitempty"`
BodyNotStartsWith *string `json:"body_not_starts_with,omitempty"`
BodyEndsWith *string `json:"body_ends_with,omitempty"`
BodyNotEndsWith *string `json:"body_not_ends_with,omitempty"`
Picture *string `json:"picture,omitempty"`
PictureNot *string `json:"picture_not,omitempty"`
PictureIn []string `json:"picture_in,omitempty"`
PictureNotIn []string `json:"picture_not_in,omitempty"`
PictureLt *string `json:"picture_lt,omitempty"`
PictureLte *string `json:"picture_lte,omitempty"`
PictureGt *string `json:"picture_gt,omitempty"`
PictureGte *string `json:"picture_gte,omitempty"`
PictureContains *string `json:"picture_contains,omitempty"`
PictureNotContains *string `json:"picture_not_contains,omitempty"`
PictureStartsWith *string `json:"picture_starts_with,omitempty"`
PictureNotStartsWith *string `json:"picture_not_starts_with,omitempty"`
PictureEndsWith *string `json:"picture_ends_with,omitempty"`
PictureNotEndsWith *string `json:"picture_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
And []PostScalarWhereInput `json:"AND,omitempty"`
Or []PostScalarWhereInput `json:"OR,omitempty"`
Not []PostScalarWhereInput `json:"NOT,omitempty"`
          }

      type CommentUpdateManyWithoutAuthorInput struct {
        Create []CommentCreateWithoutAuthorInput `json:"create,omitempty"`
Delete []CommentWhereUniqueInput `json:"delete,omitempty"`
Connect []CommentWhereUniqueInput `json:"connect,omitempty"`
Set []CommentWhereUniqueInput `json:"set,omitempty"`
Disconnect []CommentWhereUniqueInput `json:"disconnect,omitempty"`
Update []CommentUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
Upsert []CommentUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
DeleteMany []CommentScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []CommentUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type UserCreateOneWithoutCommentsInput struct {
        Create *UserCreateWithoutCommentsInput `json:"create,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikeCommentWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
QuantityNot *int32 `json:"quantity_not,omitempty"`
QuantityIn []int32 `json:"quantity_in,omitempty"`
QuantityNotIn []int32 `json:"quantity_not_in,omitempty"`
QuantityLt *int32 `json:"quantity_lt,omitempty"`
QuantityLte *int32 `json:"quantity_lte,omitempty"`
QuantityGt *int32 `json:"quantity_gt,omitempty"`
QuantityGte *int32 `json:"quantity_gte,omitempty"`
User *UserWhereInput `json:"user,omitempty"`
Comment *CommentWhereInput `json:"comment,omitempty"`
And []LikeCommentWhereInput `json:"AND,omitempty"`
Or []LikeCommentWhereInput `json:"OR,omitempty"`
Not []LikeCommentWhereInput `json:"NOT,omitempty"`
          }

      type PostCreateManyWithoutAuthorInput struct {
        Create []PostCreateWithoutAuthorInput `json:"create,omitempty"`
Connect []PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikePostWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
QuantityNot *int32 `json:"quantity_not,omitempty"`
QuantityIn []int32 `json:"quantity_in,omitempty"`
QuantityNotIn []int32 `json:"quantity_not_in,omitempty"`
QuantityLt *int32 `json:"quantity_lt,omitempty"`
QuantityLte *int32 `json:"quantity_lte,omitempty"`
QuantityGt *int32 `json:"quantity_gt,omitempty"`
QuantityGte *int32 `json:"quantity_gte,omitempty"`
User *UserWhereInput `json:"user,omitempty"`
Post *PostWhereInput `json:"post,omitempty"`
And []LikePostWhereInput `json:"AND,omitempty"`
Or []LikePostWhereInput `json:"OR,omitempty"`
Not []LikePostWhereInput `json:"NOT,omitempty"`
          }

      type CommentCreateManyWithoutPostInput struct {
        Create []CommentCreateWithoutPostInput `json:"create,omitempty"`
Connect []CommentWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpdateOneRequiredWithoutCommentsInput struct {
        Create *PostCreateWithoutCommentsInput `json:"create,omitempty"`
Update *PostUpdateWithoutCommentsDataInput `json:"update,omitempty"`
Upsert *PostUpsertWithoutCommentsInput `json:"upsert,omitempty"`
Connect *PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikeCommentCreateManyWithoutCommentInput struct {
        Create []LikeCommentCreateWithoutCommentInput `json:"create,omitempty"`
Connect []LikeCommentWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpdateWithoutCommentsDataInput struct {
        Header *string `json:"header,omitempty"`
Body *string `json:"body,omitempty"`
Picture *string `json:"picture,omitempty"`
Author *UserUpdateOneRequiredWithoutPostsInput `json:"author,omitempty"`
Likes *LikePostUpdateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type UserCreateOneWithoutCommentLikesInput struct {
        Create *UserCreateWithoutCommentLikesInput `json:"create,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type UserUpdateOneRequiredWithoutPostsInput struct {
        Create *UserCreateWithoutPostsInput `json:"create,omitempty"`
Update *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`
Upsert *UserUpsertWithoutPostsInput `json:"upsert,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type CommentCreateManyWithoutAuthorInput struct {
        Create []CommentCreateWithoutAuthorInput `json:"create,omitempty"`
Connect []CommentWhereUniqueInput `json:"connect,omitempty"`
          }

      type UserUpdateWithoutPostsDataInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Comments *CommentUpdateManyWithoutAuthorInput `json:"comments,omitempty"`
PostLikes *LikePostUpdateManyWithoutUserInput `json:"postLikes,omitempty"`
CommentLikes *LikeCommentUpdateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type PostCreateOneWithoutCommentsInput struct {
        Create *PostCreateWithoutCommentsInput `json:"create,omitempty"`
Connect *PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikePostUpdateManyWithoutUserInput struct {
        Create []LikePostCreateWithoutUserInput `json:"create,omitempty"`
Delete []LikePostWhereUniqueInput `json:"delete,omitempty"`
Connect []LikePostWhereUniqueInput `json:"connect,omitempty"`
Set []LikePostWhereUniqueInput `json:"set,omitempty"`
Disconnect []LikePostWhereUniqueInput `json:"disconnect,omitempty"`
Update []LikePostUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
Upsert []LikePostUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
DeleteMany []LikePostScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []LikePostUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type UserCreateOneWithoutPostsInput struct {
        Create *UserCreateWithoutPostsInput `json:"create,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikePostUpdateWithWhereUniqueWithoutUserInput struct {
        Where LikePostWhereUniqueInput `json:"where"`
Data LikePostUpdateWithoutUserDataInput `json:"data"`
          }

      type LikePostCreateManyWithoutUserInput struct {
        Create []LikePostCreateWithoutUserInput `json:"create,omitempty"`
Connect []LikePostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikePostUpdateWithoutUserDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
Post *PostUpdateOneRequiredWithoutLikesInput `json:"post,omitempty"`
          }

      type PostCreateOneWithoutLikesInput struct {
        Create *PostCreateWithoutLikesInput `json:"create,omitempty"`
Connect *PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpdateOneRequiredWithoutLikesInput struct {
        Create *PostCreateWithoutLikesInput `json:"create,omitempty"`
Update *PostUpdateWithoutLikesDataInput `json:"update,omitempty"`
Upsert *PostUpsertWithoutLikesInput `json:"upsert,omitempty"`
Connect *PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikeCommentCreateManyWithoutUserInput struct {
        Create []LikeCommentCreateWithoutUserInput `json:"create,omitempty"`
Connect []LikeCommentWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpdateWithoutLikesDataInput struct {
        Header *string `json:"header,omitempty"`
Body *string `json:"body,omitempty"`
Picture *string `json:"picture,omitempty"`
Author *UserUpdateOneRequiredWithoutPostsInput `json:"author,omitempty"`
Comments *CommentUpdateManyWithoutPostInput `json:"comments,omitempty"`
          }

      type CommentCreateOneWithoutLikesInput struct {
        Create *CommentCreateWithoutLikesInput `json:"create,omitempty"`
Connect *CommentWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpsertWithoutLikesInput struct {
        Update PostUpdateWithoutLikesDataInput `json:"update"`
Create PostCreateWithoutLikesInput `json:"create"`
          }

      type LikePostCreateManyWithoutPostInput struct {
        Create []LikePostCreateWithoutPostInput `json:"create,omitempty"`
Connect []LikePostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikePostUpsertWithWhereUniqueWithoutUserInput struct {
        Where LikePostWhereUniqueInput `json:"where"`
Update LikePostUpdateWithoutUserDataInput `json:"update"`
Create LikePostCreateWithoutUserInput `json:"create"`
          }

      type UserWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Email *string `json:"email,omitempty"`
EmailNot *string `json:"email_not,omitempty"`
EmailIn []string `json:"email_in,omitempty"`
EmailNotIn []string `json:"email_not_in,omitempty"`
EmailLt *string `json:"email_lt,omitempty"`
EmailLte *string `json:"email_lte,omitempty"`
EmailGt *string `json:"email_gt,omitempty"`
EmailGte *string `json:"email_gte,omitempty"`
EmailContains *string `json:"email_contains,omitempty"`
EmailNotContains *string `json:"email_not_contains,omitempty"`
EmailStartsWith *string `json:"email_starts_with,omitempty"`
EmailNotStartsWith *string `json:"email_not_starts_with,omitempty"`
EmailEndsWith *string `json:"email_ends_with,omitempty"`
EmailNotEndsWith *string `json:"email_not_ends_with,omitempty"`
Name *string `json:"name,omitempty"`
NameNot *string `json:"name_not,omitempty"`
NameIn []string `json:"name_in,omitempty"`
NameNotIn []string `json:"name_not_in,omitempty"`
NameLt *string `json:"name_lt,omitempty"`
NameLte *string `json:"name_lte,omitempty"`
NameGt *string `json:"name_gt,omitempty"`
NameGte *string `json:"name_gte,omitempty"`
NameContains *string `json:"name_contains,omitempty"`
NameNotContains *string `json:"name_not_contains,omitempty"`
NameStartsWith *string `json:"name_starts_with,omitempty"`
NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`
NameEndsWith *string `json:"name_ends_with,omitempty"`
NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`
Password *string `json:"password,omitempty"`
PasswordNot *string `json:"password_not,omitempty"`
PasswordIn []string `json:"password_in,omitempty"`
PasswordNotIn []string `json:"password_not_in,omitempty"`
PasswordLt *string `json:"password_lt,omitempty"`
PasswordLte *string `json:"password_lte,omitempty"`
PasswordGt *string `json:"password_gt,omitempty"`
PasswordGte *string `json:"password_gte,omitempty"`
PasswordContains *string `json:"password_contains,omitempty"`
PasswordNotContains *string `json:"password_not_contains,omitempty"`
PasswordStartsWith *string `json:"password_starts_with,omitempty"`
PasswordNotStartsWith *string `json:"password_not_starts_with,omitempty"`
PasswordEndsWith *string `json:"password_ends_with,omitempty"`
PasswordNotEndsWith *string `json:"password_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
PostsEvery *PostWhereInput `json:"posts_every,omitempty"`
PostsSome *PostWhereInput `json:"posts_some,omitempty"`
PostsNone *PostWhereInput `json:"posts_none,omitempty"`
CommentsEvery *CommentWhereInput `json:"comments_every,omitempty"`
CommentsSome *CommentWhereInput `json:"comments_some,omitempty"`
CommentsNone *CommentWhereInput `json:"comments_none,omitempty"`
PostLikesEvery *LikePostWhereInput `json:"postLikes_every,omitempty"`
PostLikesSome *LikePostWhereInput `json:"postLikes_some,omitempty"`
PostLikesNone *LikePostWhereInput `json:"postLikes_none,omitempty"`
CommentLikesEvery *LikeCommentWhereInput `json:"commentLikes_every,omitempty"`
CommentLikesSome *LikeCommentWhereInput `json:"commentLikes_some,omitempty"`
CommentLikesNone *LikeCommentWhereInput `json:"commentLikes_none,omitempty"`
And []UserWhereInput `json:"AND,omitempty"`
Or []UserWhereInput `json:"OR,omitempty"`
Not []UserWhereInput `json:"NOT,omitempty"`
          }

      type LikePostScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
QuantityNot *int32 `json:"quantity_not,omitempty"`
QuantityIn []int32 `json:"quantity_in,omitempty"`
QuantityNotIn []int32 `json:"quantity_not_in,omitempty"`
QuantityLt *int32 `json:"quantity_lt,omitempty"`
QuantityLte *int32 `json:"quantity_lte,omitempty"`
QuantityGt *int32 `json:"quantity_gt,omitempty"`
QuantityGte *int32 `json:"quantity_gte,omitempty"`
And []LikePostScalarWhereInput `json:"AND,omitempty"`
Or []LikePostScalarWhereInput `json:"OR,omitempty"`
Not []LikePostScalarWhereInput `json:"NOT,omitempty"`
          }

      type LikePostSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *LikePostWhereInput `json:"node,omitempty"`
And []LikePostSubscriptionWhereInput `json:"AND,omitempty"`
Or []LikePostSubscriptionWhereInput `json:"OR,omitempty"`
Not []LikePostSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LikePostUpdateManyWithWhereNestedInput struct {
        Where LikePostScalarWhereInput `json:"where"`
Data LikePostUpdateManyDataInput `json:"data"`
          }

      type UserUpdateInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
Comments *CommentUpdateManyWithoutAuthorInput `json:"comments,omitempty"`
PostLikes *LikePostUpdateManyWithoutUserInput `json:"postLikes,omitempty"`
CommentLikes *LikeCommentUpdateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type LikePostUpdateManyDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
          }

      type LikeCommentWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type LikeCommentUpdateManyWithoutUserInput struct {
        Create []LikeCommentCreateWithoutUserInput `json:"create,omitempty"`
Delete []LikeCommentWhereUniqueInput `json:"delete,omitempty"`
Connect []LikeCommentWhereUniqueInput `json:"connect,omitempty"`
Set []LikeCommentWhereUniqueInput `json:"set,omitempty"`
Disconnect []LikeCommentWhereUniqueInput `json:"disconnect,omitempty"`
Update []LikeCommentUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
Upsert []LikeCommentUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
DeleteMany []LikeCommentScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []LikeCommentUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type LikePostWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type LikeCommentUpdateWithWhereUniqueWithoutUserInput struct {
        Where LikeCommentWhereUniqueInput `json:"where"`
Data LikeCommentUpdateWithoutUserDataInput `json:"data"`
          }

      type PostWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type LikeCommentUpdateWithoutUserDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
Comment *CommentUpdateOneRequiredWithoutLikesInput `json:"comment,omitempty"`
          }

      type UserWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
Email *string `json:"email,omitempty"`
          }

      type CommentUpdateOneRequiredWithoutLikesInput struct {
        Create *CommentCreateWithoutLikesInput `json:"create,omitempty"`
Update *CommentUpdateWithoutLikesDataInput `json:"update,omitempty"`
Upsert *CommentUpsertWithoutLikesInput `json:"upsert,omitempty"`
Connect *CommentWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpsertWithWhereUniqueWithoutAuthorInput struct {
        Where PostWhereUniqueInput `json:"where"`
Update PostUpdateWithoutAuthorDataInput `json:"update"`
Create PostCreateWithoutAuthorInput `json:"create"`
          }

      type CommentUpdateWithoutLikesDataInput struct {
        Body *string `json:"body,omitempty"`
Author *UserUpdateOneRequiredWithoutCommentsInput `json:"author,omitempty"`
Post *PostUpdateOneRequiredWithoutCommentsInput `json:"post,omitempty"`
          }

      type UserCreateWithoutCommentsInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
PostLikes *LikePostCreateManyWithoutUserInput `json:"postLikes,omitempty"`
CommentLikes *LikeCommentCreateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type CommentUpsertWithoutLikesInput struct {
        Update CommentUpdateWithoutLikesDataInput `json:"update"`
Create CommentCreateWithoutLikesInput `json:"create"`
          }

      type CommentCreateWithoutPostInput struct {
        ID *string `json:"id,omitempty"`
Body string `json:"body"`
Author UserCreateOneWithoutCommentsInput `json:"author"`
Likes *LikeCommentCreateManyWithoutCommentInput `json:"likes,omitempty"`
          }

      type LikeCommentUpsertWithWhereUniqueWithoutUserInput struct {
        Where LikeCommentWhereUniqueInput `json:"where"`
Update LikeCommentUpdateWithoutUserDataInput `json:"update"`
Create LikeCommentCreateWithoutUserInput `json:"create"`
          }

      type UserCreateWithoutCommentLikesInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
Comments *CommentCreateManyWithoutAuthorInput `json:"comments,omitempty"`
PostLikes *LikePostCreateManyWithoutUserInput `json:"postLikes,omitempty"`
          }

      type LikeCommentScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
QuantityNot *int32 `json:"quantity_not,omitempty"`
QuantityIn []int32 `json:"quantity_in,omitempty"`
QuantityNotIn []int32 `json:"quantity_not_in,omitempty"`
QuantityLt *int32 `json:"quantity_lt,omitempty"`
QuantityLte *int32 `json:"quantity_lte,omitempty"`
QuantityGt *int32 `json:"quantity_gt,omitempty"`
QuantityGte *int32 `json:"quantity_gte,omitempty"`
And []LikeCommentScalarWhereInput `json:"AND,omitempty"`
Or []LikeCommentScalarWhereInput `json:"OR,omitempty"`
Not []LikeCommentScalarWhereInput `json:"NOT,omitempty"`
          }

      type PostCreateWithoutCommentsInput struct {
        ID *string `json:"id,omitempty"`
Header string `json:"header"`
Body string `json:"body"`
Picture *string `json:"picture,omitempty"`
Author UserCreateOneWithoutPostsInput `json:"author"`
Likes *LikePostCreateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type LikeCommentUpdateManyWithWhereNestedInput struct {
        Where LikeCommentScalarWhereInput `json:"where"`
Data LikeCommentUpdateManyDataInput `json:"data"`
          }

      type LikePostCreateWithoutUserInput struct {
        ID *string `json:"id,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
Post PostCreateOneWithoutLikesInput `json:"post"`
          }

      type LikeCommentUpdateManyDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
          }

      type LikeCommentCreateWithoutUserInput struct {
        ID *string `json:"id,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
Comment CommentCreateOneWithoutLikesInput `json:"comment"`
          }

      type UserUpsertWithoutPostsInput struct {
        Update UserUpdateWithoutPostsDataInput `json:"update"`
Create UserCreateWithoutPostsInput `json:"create"`
          }

      type LikePostCreateWithoutPostInput struct {
        ID *string `json:"id,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
User UserCreateOneWithoutPostLikesInput `json:"user"`
          }

      type LikePostUpdateManyWithoutPostInput struct {
        Create []LikePostCreateWithoutPostInput `json:"create,omitempty"`
Delete []LikePostWhereUniqueInput `json:"delete,omitempty"`
Connect []LikePostWhereUniqueInput `json:"connect,omitempty"`
Set []LikePostWhereUniqueInput `json:"set,omitempty"`
Disconnect []LikePostWhereUniqueInput `json:"disconnect,omitempty"`
Update []LikePostUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
Upsert []LikePostUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
DeleteMany []LikePostScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []LikePostUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type CommentSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *CommentWhereInput `json:"node,omitempty"`
And []CommentSubscriptionWhereInput `json:"AND,omitempty"`
Or []CommentSubscriptionWhereInput `json:"OR,omitempty"`
Not []CommentSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LikePostUpdateWithWhereUniqueWithoutPostInput struct {
        Where LikePostWhereUniqueInput `json:"where"`
Data LikePostUpdateWithoutPostDataInput `json:"data"`
          }

      type LikePostUpdateManyMutationInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
          }

      type LikePostUpdateWithoutPostDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
User *UserUpdateOneRequiredWithoutPostLikesInput `json:"user,omitempty"`
          }

      type CommentUpdateManyMutationInput struct {
        Body *string `json:"body,omitempty"`
          }

      type UserUpdateOneRequiredWithoutPostLikesInput struct {
        Create *UserCreateWithoutPostLikesInput `json:"create,omitempty"`
Update *UserUpdateWithoutPostLikesDataInput `json:"update,omitempty"`
Upsert *UserUpsertWithoutPostLikesInput `json:"upsert,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type CommentCreateInput struct {
        ID *string `json:"id,omitempty"`
Body string `json:"body"`
Author UserCreateOneWithoutCommentsInput `json:"author"`
Post PostCreateOneWithoutCommentsInput `json:"post"`
Likes *LikeCommentCreateManyWithoutCommentInput `json:"likes,omitempty"`
          }

      type UserUpdateWithoutPostLikesDataInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
Comments *CommentUpdateManyWithoutAuthorInput `json:"comments,omitempty"`
CommentLikes *LikeCommentUpdateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type LikeCommentCreateWithoutCommentInput struct {
        ID *string `json:"id,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
User UserCreateOneWithoutCommentLikesInput `json:"user"`
          }

      type UserUpsertWithoutPostLikesInput struct {
        Update UserUpdateWithoutPostLikesDataInput `json:"update"`
Create UserCreateWithoutPostLikesInput `json:"create"`
          }

      type UserCreateWithoutPostsInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Comments *CommentCreateManyWithoutAuthorInput `json:"comments,omitempty"`
PostLikes *LikePostCreateManyWithoutUserInput `json:"postLikes,omitempty"`
CommentLikes *LikeCommentCreateManyWithoutUserInput `json:"commentLikes,omitempty"`
          }

      type LikePostUpsertWithWhereUniqueWithoutPostInput struct {
        Where LikePostWhereUniqueInput `json:"where"`
Update LikePostUpdateWithoutPostDataInput `json:"update"`
Create LikePostCreateWithoutPostInput `json:"create"`
          }

      type CommentCreateWithoutLikesInput struct {
        ID *string `json:"id,omitempty"`
Body string `json:"body"`
Author UserCreateOneWithoutCommentsInput `json:"author"`
Post PostCreateOneWithoutCommentsInput `json:"post"`
          }

      type PostUpsertWithoutCommentsInput struct {
        Update PostUpdateWithoutCommentsDataInput `json:"update"`
Create PostCreateWithoutCommentsInput `json:"create"`
          }

      type PostUpdateManyMutationInput struct {
        Header *string `json:"header,omitempty"`
Body *string `json:"body,omitempty"`
Picture *string `json:"picture,omitempty"`
          }

      type CommentUpsertWithWhereUniqueWithoutAuthorInput struct {
        Where CommentWhereUniqueInput `json:"where"`
Update CommentUpdateWithoutAuthorDataInput `json:"update"`
Create CommentCreateWithoutAuthorInput `json:"create"`
          }

      type PostUpdateManyWithWhereNestedInput struct {
        Where PostScalarWhereInput `json:"where"`
Data PostUpdateManyDataInput `json:"data"`
          }

      type UserUpsertWithoutCommentLikesInput struct {
        Update UserUpdateWithoutCommentLikesDataInput `json:"update"`
Create UserCreateWithoutCommentLikesInput `json:"create"`
          }

      type CommentUpdateManyDataInput struct {
        Body *string `json:"body,omitempty"`
          }

      type CommentUpdateManyWithWhereNestedInput struct {
        Where CommentScalarWhereInput `json:"where"`
Data CommentUpdateManyDataInput `json:"data"`
          }

      type CommentScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Body *string `json:"body,omitempty"`
BodyNot *string `json:"body_not,omitempty"`
BodyIn []string `json:"body_in,omitempty"`
BodyNotIn []string `json:"body_not_in,omitempty"`
BodyLt *string `json:"body_lt,omitempty"`
BodyLte *string `json:"body_lte,omitempty"`
BodyGt *string `json:"body_gt,omitempty"`
BodyGte *string `json:"body_gte,omitempty"`
BodyContains *string `json:"body_contains,omitempty"`
BodyNotContains *string `json:"body_not_contains,omitempty"`
BodyStartsWith *string `json:"body_starts_with,omitempty"`
BodyNotStartsWith *string `json:"body_not_starts_with,omitempty"`
BodyEndsWith *string `json:"body_ends_with,omitempty"`
BodyNotEndsWith *string `json:"body_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
And []CommentScalarWhereInput `json:"AND,omitempty"`
Or []CommentScalarWhereInput `json:"OR,omitempty"`
Not []CommentScalarWhereInput `json:"NOT,omitempty"`
          }

      type PostCreateWithoutAuthorInput struct {
        ID *string `json:"id,omitempty"`
Header string `json:"header"`
Body string `json:"body"`
Picture *string `json:"picture,omitempty"`
Comments *CommentCreateManyWithoutPostInput `json:"comments,omitempty"`
Likes *LikePostCreateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type LikeCommentUpdateManyMutationInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
          }

      type PostWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Header *string `json:"header,omitempty"`
HeaderNot *string `json:"header_not,omitempty"`
HeaderIn []string `json:"header_in,omitempty"`
HeaderNotIn []string `json:"header_not_in,omitempty"`
HeaderLt *string `json:"header_lt,omitempty"`
HeaderLte *string `json:"header_lte,omitempty"`
HeaderGt *string `json:"header_gt,omitempty"`
HeaderGte *string `json:"header_gte,omitempty"`
HeaderContains *string `json:"header_contains,omitempty"`
HeaderNotContains *string `json:"header_not_contains,omitempty"`
HeaderStartsWith *string `json:"header_starts_with,omitempty"`
HeaderNotStartsWith *string `json:"header_not_starts_with,omitempty"`
HeaderEndsWith *string `json:"header_ends_with,omitempty"`
HeaderNotEndsWith *string `json:"header_not_ends_with,omitempty"`
Body *string `json:"body,omitempty"`
BodyNot *string `json:"body_not,omitempty"`
BodyIn []string `json:"body_in,omitempty"`
BodyNotIn []string `json:"body_not_in,omitempty"`
BodyLt *string `json:"body_lt,omitempty"`
BodyLte *string `json:"body_lte,omitempty"`
BodyGt *string `json:"body_gt,omitempty"`
BodyGte *string `json:"body_gte,omitempty"`
BodyContains *string `json:"body_contains,omitempty"`
BodyNotContains *string `json:"body_not_contains,omitempty"`
BodyStartsWith *string `json:"body_starts_with,omitempty"`
BodyNotStartsWith *string `json:"body_not_starts_with,omitempty"`
BodyEndsWith *string `json:"body_ends_with,omitempty"`
BodyNotEndsWith *string `json:"body_not_ends_with,omitempty"`
Picture *string `json:"picture,omitempty"`
PictureNot *string `json:"picture_not,omitempty"`
PictureIn []string `json:"picture_in,omitempty"`
PictureNotIn []string `json:"picture_not_in,omitempty"`
PictureLt *string `json:"picture_lt,omitempty"`
PictureLte *string `json:"picture_lte,omitempty"`
PictureGt *string `json:"picture_gt,omitempty"`
PictureGte *string `json:"picture_gte,omitempty"`
PictureContains *string `json:"picture_contains,omitempty"`
PictureNotContains *string `json:"picture_not_contains,omitempty"`
PictureStartsWith *string `json:"picture_starts_with,omitempty"`
PictureNotStartsWith *string `json:"picture_not_starts_with,omitempty"`
PictureEndsWith *string `json:"picture_ends_with,omitempty"`
PictureNotEndsWith *string `json:"picture_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Author *UserWhereInput `json:"author,omitempty"`
CommentsEvery *CommentWhereInput `json:"comments_every,omitempty"`
CommentsSome *CommentWhereInput `json:"comments_some,omitempty"`
CommentsNone *CommentWhereInput `json:"comments_none,omitempty"`
LikesEvery *LikePostWhereInput `json:"likes_every,omitempty"`
LikesSome *LikePostWhereInput `json:"likes_some,omitempty"`
LikesNone *LikePostWhereInput `json:"likes_none,omitempty"`
And []PostWhereInput `json:"AND,omitempty"`
Or []PostWhereInput `json:"OR,omitempty"`
Not []PostWhereInput `json:"NOT,omitempty"`
          }

      type PostCreateWithoutLikesInput struct {
        ID *string `json:"id,omitempty"`
Header string `json:"header"`
Body string `json:"body"`
Picture *string `json:"picture,omitempty"`
Author UserCreateOneWithoutPostsInput `json:"author"`
Comments *CommentCreateManyWithoutPostInput `json:"comments,omitempty"`
          }

      type CommentCreateWithoutAuthorInput struct {
        ID *string `json:"id,omitempty"`
Body string `json:"body"`
Post PostCreateOneWithoutCommentsInput `json:"post"`
Likes *LikeCommentCreateManyWithoutCommentInput `json:"likes,omitempty"`
          }


        type UserPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
                  var v UserPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
            var v []UserPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserPreviousValuesFields = []string{"id", "email", "name", "password", "createdAt"}

        type UserPreviousValues struct {
          ID string `json:"id"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
CreatedAt string `json:"createdAt"`
        }

        type CommentEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CommentEdgeExec) Node() *CommentExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Comment"},
                    "node",
                    []string{"id","body","createdAt","updatedAt"})

                  return &CommentExec{ret}
                }

          
                func (instance CommentEdgeExec) Exec(ctx context.Context) (*CommentEdge, error) {
                  var v CommentEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance CommentEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CommentEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance CommentEdgeExecArray) Exec(ctx context.Context) ([]CommentEdge, error) {
            var v []CommentEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var CommentEdgeFields = []string{"cursor"}

        type CommentEdge struct {
          Node Comment `json:"node"`
Cursor string `json:"cursor"`
        }

        type PostSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostSubscriptionPayloadExec) Node() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "node",
                    []string{"id","header","body","picture","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

                func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PostPreviousValues"},
                    "previousValues",
                    []string{"id","header","body","picture","createdAt","updatedAt"})

                  return &PostPreviousValuesExec{ret}
                }

          
                func (instance PostSubscriptionPayloadExec) Exec(ctx context.Context) (*PostSubscriptionPayload, error) {
                  var v PostSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PostSubscriptionPayload, error) {
            var v []PostSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type PostSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *Post `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type UserConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "User"},
                      "node",
                      UserFields)

                    return &UserEdgeExecArray{nodes}
                  }

                  func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateUser"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &UserConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
            var v []UserConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserConnectionFields = []string{}

        type UserConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []UserEdge `json:"edges"`
        }

        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
                  var v PageInfo
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }


        type CommentConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CommentConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *CommentConnectionExec) Edges() *CommentEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"CommentWhereInput", "CommentOrderByInput", "CommentEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "Comment"},
                      "node",
                      CommentFields)

                    return &CommentEdgeExecArray{nodes}
                  }

                  func (instance *CommentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateComment"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance CommentConnectionExec) Exec(ctx context.Context) (*CommentConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &CommentConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance CommentConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CommentConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance CommentConnectionExecArray) Exec(ctx context.Context) ([]CommentConnection, error) {
            var v []CommentConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var CommentConnectionFields = []string{}

        type CommentConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []CommentEdge `json:"edges"`
        }


        type LikeCommentExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikeCommentExec) User() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "user",
                    []string{"id","email","name","password","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *LikeCommentExec) Comment() *CommentExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Comment"},
                    "comment",
                    []string{"id","body","createdAt","updatedAt"})

                  return &CommentExec{ret}
                }

          
                func (instance LikeCommentExec) Exec(ctx context.Context) (*LikeComment, error) {
                  var v LikeComment
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikeCommentExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikeCommentExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikeCommentExecArray) Exec(ctx context.Context) ([]LikeComment, error) {
            var v []LikeComment
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikeCommentFields = []string{"id", "createdAt", "updatedAt", "quantity"}

        type LikeComment struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Quantity *int32 `json:"quantity,omitempty"`
        }

        func (LikeComment) IsLike() {}

        type PostConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *PostConnectionExec) Edges() *PostEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"PostWhereInput", "PostOrderByInput", "PostEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "Post"},
                      "node",
                      PostFields)

                    return &PostEdgeExecArray{nodes}
                  }

                  func (instance *PostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregatePost"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance PostConnectionExec) Exec(ctx context.Context) (*PostConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &PostConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance PostConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostConnectionExecArray) Exec(ctx context.Context) ([]PostConnection, error) {
            var v []PostConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostConnectionFields = []string{}

        type PostConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []PostEdge `json:"edges"`
        }

        type CommentExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CommentExec) Author() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "author",
                    []string{"id","email","name","password","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *CommentExec) Post() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "post",
                    []string{"id","header","body","picture","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

                type LikesParamsExec struct {
                  Where *LikeCommentWhereInput
OrderBy *LikeCommentOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *CommentExec) Likes(params *LikesParamsExec) *LikeCommentExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"LikeCommentWhereInput", "LikeCommentOrderByInput", "LikeComment"},
                    "likes",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikeCommentExecArray{ret}
                }

          
                func (instance CommentExec) Exec(ctx context.Context) (*Comment, error) {
                  var v Comment
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance CommentExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CommentExecArray struct {
            exec *prisma.Exec
          }

          func (instance CommentExecArray) Exec(ctx context.Context) ([]Comment, error) {
            var v []Comment
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var CommentFields = []string{"id", "body", "createdAt", "updatedAt"}

        type Comment struct {
          ID string `json:"id"`
Body string `json:"body"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type LikePostEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikePostEdgeExec) Node() *LikePostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikePost"},
                    "node",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikePostExec{ret}
                }

          
                func (instance LikePostEdgeExec) Exec(ctx context.Context) (*LikePostEdge, error) {
                  var v LikePostEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikePostEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikePostEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikePostEdgeExecArray) Exec(ctx context.Context) ([]LikePostEdge, error) {
            var v []LikePostEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikePostEdgeFields = []string{"cursor"}

        type LikePostEdge struct {
          Node LikePost `json:"node"`
Cursor string `json:"cursor"`
        }

        type CommentSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CommentSubscriptionPayloadExec) Node() *CommentExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Comment"},
                    "node",
                    []string{"id","body","createdAt","updatedAt"})

                  return &CommentExec{ret}
                }

                func (instance *CommentSubscriptionPayloadExec) PreviousValues() *CommentPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CommentPreviousValues"},
                    "previousValues",
                    []string{"id","body","createdAt","updatedAt"})

                  return &CommentPreviousValuesExec{ret}
                }

          
                func (instance CommentSubscriptionPayloadExec) Exec(ctx context.Context) (*CommentSubscriptionPayload, error) {
                  var v CommentSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance CommentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CommentSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance CommentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CommentSubscriptionPayload, error) {
            var v []CommentSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var CommentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type CommentSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *Comment `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type CommentPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance CommentPreviousValuesExec) Exec(ctx context.Context) (*CommentPreviousValues, error) {
                  var v CommentPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance CommentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CommentPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance CommentPreviousValuesExecArray) Exec(ctx context.Context) ([]CommentPreviousValues, error) {
            var v []CommentPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var CommentPreviousValuesFields = []string{"id", "body", "createdAt", "updatedAt"}

        type CommentPreviousValues struct {
          ID string `json:"id"`
Body string `json:"body"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type LikeCommentConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikeCommentConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *LikeCommentConnectionExec) Edges() *LikeCommentEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"LikeCommentWhereInput", "LikeCommentOrderByInput", "LikeCommentEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "LikeComment"},
                      "node",
                      LikeCommentFields)

                    return &LikeCommentEdgeExecArray{nodes}
                  }

                  func (instance *LikeCommentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateLikeComment"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance LikeCommentConnectionExec) Exec(ctx context.Context) (*LikeCommentConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &LikeCommentConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance LikeCommentConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikeCommentConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikeCommentConnectionExecArray) Exec(ctx context.Context) ([]LikeCommentConnection, error) {
            var v []LikeCommentConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikeCommentConnectionFields = []string{}

        type LikeCommentConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []LikeCommentEdge `json:"edges"`
        }

        type PostPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance PostPreviousValuesExec) Exec(ctx context.Context) (*PostPreviousValues, error) {
                  var v PostPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostPreviousValuesExecArray) Exec(ctx context.Context) ([]PostPreviousValues, error) {
            var v []PostPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostPreviousValuesFields = []string{"id", "header", "body", "picture", "createdAt", "updatedAt"}

        type PostPreviousValues struct {
          ID string `json:"id"`
Header string `json:"header"`
Body string `json:"body"`
Picture *string `json:"picture,omitempty"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type UserEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserEdgeExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","email","name","password","createdAt"})

                  return &UserExec{ret}
                }

          
                func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
                  var v UserEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
            var v []UserEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserEdgeFields = []string{"cursor"}

        type UserEdge struct {
          Node User `json:"node"`
Cursor string `json:"cursor"`
        }

        type LikeCommentSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikeCommentSubscriptionPayloadExec) Node() *LikeCommentExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikeComment"},
                    "node",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikeCommentExec{ret}
                }

                func (instance *LikeCommentSubscriptionPayloadExec) PreviousValues() *LikeCommentPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikeCommentPreviousValues"},
                    "previousValues",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikeCommentPreviousValuesExec{ret}
                }

          
                func (instance LikeCommentSubscriptionPayloadExec) Exec(ctx context.Context) (*LikeCommentSubscriptionPayload, error) {
                  var v LikeCommentSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikeCommentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikeCommentSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikeCommentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LikeCommentSubscriptionPayload, error) {
            var v []LikeCommentSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikeCommentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type LikeCommentSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *LikeComment `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type PostEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostEdgeExec) Node() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "node",
                    []string{"id","header","body","picture","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

          
                func (instance PostEdgeExec) Exec(ctx context.Context) (*PostEdge, error) {
                  var v PostEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostEdgeExecArray) Exec(ctx context.Context) ([]PostEdge, error) {
            var v []PostEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostEdgeFields = []string{"cursor"}

        type PostEdge struct {
          Node Post `json:"node"`
Cursor string `json:"cursor"`
        }

        type LikeCommentPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance LikeCommentPreviousValuesExec) Exec(ctx context.Context) (*LikeCommentPreviousValues, error) {
                  var v LikeCommentPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikeCommentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikeCommentPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikeCommentPreviousValuesExecArray) Exec(ctx context.Context) ([]LikeCommentPreviousValues, error) {
            var v []LikeCommentPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikeCommentPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "quantity"}

        type LikeCommentPreviousValues struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Quantity *int32 `json:"quantity,omitempty"`
        }


        type UserExec struct {
          exec *prisma.Exec
        }

        
                type PostsParamsExec struct {
                  Where *PostWhereInput
OrderBy *PostOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *UserExec) Posts(params *PostsParamsExec) *PostExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"PostWhereInput", "PostOrderByInput", "Post"},
                    "posts",
                    []string{"id","header","body","picture","createdAt","updatedAt"})

                  return &PostExecArray{ret}
                }

                type CommentsParamsExec struct {
                  Where *CommentWhereInput
OrderBy *CommentOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *UserExec) Comments(params *CommentsParamsExec) *CommentExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
                    "comments",
                    []string{"id","body","createdAt","updatedAt"})

                  return &CommentExecArray{ret}
                }

                type PostLikesParamsExec struct {
                  Where *LikePostWhereInput
OrderBy *LikePostOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *UserExec) PostLikes(params *PostLikesParamsExec) *LikePostExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"LikePostWhereInput", "LikePostOrderByInput", "LikePost"},
                    "postLikes",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikePostExecArray{ret}
                }

                type CommentLikesParamsExec struct {
                  Where *LikeCommentWhereInput
OrderBy *LikeCommentOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *UserExec) CommentLikes(params *CommentLikesParamsExec) *LikeCommentExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"LikeCommentWhereInput", "LikeCommentOrderByInput", "LikeComment"},
                    "commentLikes",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikeCommentExecArray{ret}
                }

          
                func (instance UserExec) Exec(ctx context.Context) (*User, error) {
                  var v User
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
            var v []User
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserFields = []string{"id", "email", "name", "password", "createdAt"}

        type User struct {
          ID string `json:"id"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
CreatedAt string `json:"createdAt"`
        }

        type LikePostPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance LikePostPreviousValuesExec) Exec(ctx context.Context) (*LikePostPreviousValues, error) {
                  var v LikePostPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikePostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikePostPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikePostPreviousValuesExecArray) Exec(ctx context.Context) ([]LikePostPreviousValues, error) {
            var v []LikePostPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikePostPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "quantity"}

        type LikePostPreviousValues struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Quantity *int32 `json:"quantity,omitempty"`
        }

        type LikePostSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikePostSubscriptionPayloadExec) Node() *LikePostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikePost"},
                    "node",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikePostExec{ret}
                }

                func (instance *LikePostSubscriptionPayloadExec) PreviousValues() *LikePostPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikePostPreviousValues"},
                    "previousValues",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikePostPreviousValuesExec{ret}
                }

          
                func (instance LikePostSubscriptionPayloadExec) Exec(ctx context.Context) (*LikePostSubscriptionPayload, error) {
                  var v LikePostSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikePostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikePostSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikePostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LikePostSubscriptionPayload, error) {
            var v []LikePostSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikePostSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type LikePostSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *LikePost `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type LikePostExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikePostExec) User() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "user",
                    []string{"id","email","name","password","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *LikePostExec) Post() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "post",
                    []string{"id","header","body","picture","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

          
                func (instance LikePostExec) Exec(ctx context.Context) (*LikePost, error) {
                  var v LikePost
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikePostExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikePostExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikePostExecArray) Exec(ctx context.Context) ([]LikePost, error) {
            var v []LikePost
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikePostFields = []string{"id", "createdAt", "updatedAt", "quantity"}

        type LikePost struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Quantity *int32 `json:"quantity,omitempty"`
        }

        func (LikePost) IsLike() {}

        type LikePostConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikePostConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *LikePostConnectionExec) Edges() *LikePostEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"LikePostWhereInput", "LikePostOrderByInput", "LikePostEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "LikePost"},
                      "node",
                      LikePostFields)

                    return &LikePostEdgeExecArray{nodes}
                  }

                  func (instance *LikePostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateLikePost"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance LikePostConnectionExec) Exec(ctx context.Context) (*LikePostConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &LikePostConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance LikePostConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikePostConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikePostConnectionExecArray) Exec(ctx context.Context) ([]LikePostConnection, error) {
            var v []LikePostConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikePostConnectionFields = []string{}

        type LikePostConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []LikePostEdge `json:"edges"`
        }

        type PostExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostExec) Author() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "author",
                    []string{"id","email","name","password","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *PostExec) Comments(params *CommentsParamsExec) *CommentExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
                    "comments",
                    []string{"id","body","createdAt","updatedAt"})

                  return &CommentExecArray{ret}
                }

                func (instance *PostExec) Likes(params *LikesParamsExec) *LikePostExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"LikePostWhereInput", "LikePostOrderByInput", "LikePost"},
                    "likes",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikePostExecArray{ret}
                }

          
                func (instance PostExec) Exec(ctx context.Context) (*Post, error) {
                  var v Post
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostExecArray) Exec(ctx context.Context) ([]Post, error) {
            var v []Post
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostFields = []string{"id", "header", "body", "picture", "createdAt", "updatedAt"}

        type Post struct {
          ID string `json:"id"`
Header string `json:"header"`
Body string `json:"body"`
Picture *string `json:"picture,omitempty"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type UserSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","email","name","password","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "UserPreviousValues"},
                    "previousValues",
                    []string{"id","email","name","password","createdAt"})

                  return &UserPreviousValuesExec{ret}
                }

          
                func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
                  var v UserSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
            var v []UserSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type UserSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *User `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type LikeCommentEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikeCommentEdgeExec) Node() *LikeCommentExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikeComment"},
                    "node",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikeCommentExec{ret}
                }

          
                func (instance LikeCommentEdgeExec) Exec(ctx context.Context) (*LikeCommentEdge, error) {
                  var v LikeCommentEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikeCommentEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikeCommentEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikeCommentEdgeExecArray) Exec(ctx context.Context) ([]LikeCommentEdge, error) {
            var v []LikeCommentEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikeCommentEdgeFields = []string{"cursor"}

        type LikeCommentEdge struct {
          Node LikeComment `json:"node"`
Cursor string `json:"cursor"`
        }






        