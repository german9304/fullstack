
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"

  

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = "http://prisma:4466/fullstackapp/posts"
var Secret          = ""


      func (client *Client) Likes (params LikesWhereUniqueInput) *LikesExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"LikesWhereUniqueInput!", "Likes"},
          "likes",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikesExec{ret}
      }

      type LikesesParams struct {
        Where *LikesWhereInput `json:"where,omitempty"`
OrderBy *LikesOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Likeses (params *LikesesParams) *LikesExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LikesWhereInput", "LikesOrderByInput", "Likes"},
          "likeses",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikesExecArray{ret}
      }

      type LikesesConnectionParams struct {
        Where *LikesWhereInput `json:"where,omitempty"`
OrderBy *LikesOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *LikesConnection) Nodes() []Likes {
        var nodes []Likes
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *LikesConnection) NodesPtr() []*Likes {
        var nodes []*Likes
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) LikesesConnection (params *LikesesConnectionParams) (*LikesConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LikesWhereInput", "LikesOrderByInput", "Likes"},
          "likesesConnection",
          []string{"edges", "pageInfo"})

        return &LikesConnectionExec{ret}
      }

      func (client *Client) Post (params PostWhereUniqueInput) *PostExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"PostWhereUniqueInput!", "Post"},
          "post",
          []string{"id","text","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      type PostsParams struct {
        Where *PostWhereInput `json:"where,omitempty"`
OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Posts (params *PostsParams) *PostExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"PostWhereInput", "PostOrderByInput", "Post"},
          "posts",
          []string{"id","text","createdAt","updatedAt"})

        return &PostExecArray{ret}
      }

      type PostsConnectionParams struct {
        Where *PostWhereInput `json:"where,omitempty"`
OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *PostConnection) Nodes() []Post {
        var nodes []Post
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *PostConnection) NodesPtr() []*Post {
        var nodes []*Post
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) PostsConnection (params *PostsConnectionParams) (*PostConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"PostWhereInput", "PostOrderByInput", "Post"},
          "postsConnection",
          []string{"edges", "pageInfo"})

        return &PostConnectionExec{ret}
      }

      func (client *Client) User (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "user",
          []string{"id","email","name","password","age","createdAt"})

        return &UserExec{ret}
      }

      type UsersParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Users (params *UsersParams) *UserExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "users",
          []string{"id","email","name","password","age","createdAt"})

        return &UserExecArray{ret}
      }

      type UsersConnectionParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      // Nodes return just nodes without cursors. It uses the already fetched edges.
      func (s *UserConnection) Nodes() []User {
        var nodes []User
        for _, edge := range s.Edges {
          nodes = append(nodes, edge.Node)
        }
        return nodes
      }

      // Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
      func (s *UserConnection) NodesPtr() []*User {
        var nodes []*User
        for _, edge := range s.Edges {
          item := edge
          nodes = append(nodes, &item.Node)
        }
        return nodes
      }

      func (client *Client) UsersConnection (params *UsersConnectionParams) (*UserConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "usersConnection",
          []string{"edges", "pageInfo"})

        return &UserConnectionExec{ret}
      }



      func (client *Client) CreateLikes (params LikesCreateInput) *LikesExec {
        ret := client.Client.Create(
          params,
          [2]string{"LikesCreateInput!", "Likes"},
          "createLikes",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikesExec{ret}
      }

      type LikesUpdateParams struct {
        Data LikesUpdateInput `json:"data"`
Where LikesWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateLikes (params LikesUpdateParams) *LikesExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"LikesUpdateInput!", "LikesWhereUniqueInput!", "Likes"},
                 "updateLikes",
                 []string{"id","createdAt","updatedAt","quantity"})

        return &LikesExec{ret}
      }

      type LikesUpdateManyParams struct {
        Data LikesUpdateManyMutationInput `json:"data"`
Where *LikesWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyLikeses (params LikesUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"LikesUpdateManyMutationInput!", "LikesWhereInput"},
          "updateManyLikeses")
        return &BatchPayloadExec{exec}
      }

      type LikesUpsertParams struct {
        Where LikesWhereUniqueInput `json:"where"`
Create LikesCreateInput `json:"create"`
Update LikesUpdateInput `json:"update"`
      }
      func (client *Client) UpsertLikes (params LikesUpsertParams) *LikesExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"LikesWhereUniqueInput!", "LikesCreateInput!", "LikesUpdateInput!","Likes"},
          "upsertLikes",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikesExec{ret}
      }

      func (client *Client) DeleteLikes (params LikesWhereUniqueInput) *LikesExec {
        ret := client.Client.Delete(
          params,
          [2]string{"LikesWhereUniqueInput!", "Likes"},
          "deleteLikes",
          []string{"id","createdAt","updatedAt","quantity"})

        return &LikesExec{ret}
      }

      func (client *Client) DeleteManyLikeses (params *LikesWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "LikesWhereInput", "deleteManyLikeses")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreatePost (params PostCreateInput) *PostExec {
        ret := client.Client.Create(
          params,
          [2]string{"PostCreateInput!", "Post"},
          "createPost",
          []string{"id","text","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      type PostUpdateParams struct {
        Data PostUpdateInput `json:"data"`
Where PostWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdatePost (params PostUpdateParams) *PostExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"PostUpdateInput!", "PostWhereUniqueInput!", "Post"},
                 "updatePost",
                 []string{"id","text","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      type PostUpdateManyParams struct {
        Data PostUpdateManyMutationInput `json:"data"`
Where *PostWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyPosts (params PostUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"PostUpdateManyMutationInput!", "PostWhereInput"},
          "updateManyPosts")
        return &BatchPayloadExec{exec}
      }

      type PostUpsertParams struct {
        Where PostWhereUniqueInput `json:"where"`
Create PostCreateInput `json:"create"`
Update PostUpdateInput `json:"update"`
      }
      func (client *Client) UpsertPost (params PostUpsertParams) *PostExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"PostWhereUniqueInput!", "PostCreateInput!", "PostUpdateInput!","Post"},
          "upsertPost",
          []string{"id","text","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      func (client *Client) DeletePost (params PostWhereUniqueInput) *PostExec {
        ret := client.Client.Delete(
          params,
          [2]string{"PostWhereUniqueInput!", "Post"},
          "deletePost",
          []string{"id","text","createdAt","updatedAt"})

        return &PostExec{ret}
      }

      func (client *Client) DeleteManyPosts (params *PostWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "PostWhereInput", "deleteManyPosts")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateUser (params UserCreateInput) *UserExec {
        ret := client.Client.Create(
          params,
          [2]string{"UserCreateInput!", "User"},
          "createUser",
          []string{"id","email","name","password","age","createdAt"})

        return &UserExec{ret}
      }

      type UserUpdateParams struct {
        Data UserUpdateInput `json:"data"`
Where UserWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateUser (params UserUpdateParams) *UserExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
                 "updateUser",
                 []string{"id","email","name","password","age","createdAt"})

        return &UserExec{ret}
      }

      type UserUpdateManyParams struct {
        Data UserUpdateManyMutationInput `json:"data"`
Where *UserWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyUsers (params UserUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
          "updateManyUsers")
        return &BatchPayloadExec{exec}
      }

      type UserUpsertParams struct {
        Where UserWhereUniqueInput `json:"where"`
Create UserCreateInput `json:"create"`
Update UserUpdateInput `json:"update"`
      }
      func (client *Client) UpsertUser (params UserUpsertParams) *UserExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!","User"},
          "upsertUser",
          []string{"id","email","name","password","age","createdAt"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteUser (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.Delete(
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "deleteUser",
          []string{"id","email","name","password","age","createdAt"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteManyUsers (params *UserWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
        return &BatchPayloadExec{exec}
      }


        type PostOrderByInput string
        const (
          PostOrderByInputIDAsc PostOrderByInput = "id_ASC"
PostOrderByInputIDDesc PostOrderByInput = "id_DESC"
PostOrderByInputTextAsc PostOrderByInput = "text_ASC"
PostOrderByInputTextDesc PostOrderByInput = "text_DESC"
PostOrderByInputCreatedAtAsc PostOrderByInput = "createdAt_ASC"
PostOrderByInputCreatedAtDesc PostOrderByInput = "createdAt_DESC"
PostOrderByInputUpdatedAtAsc PostOrderByInput = "updatedAt_ASC"
PostOrderByInputUpdatedAtDesc PostOrderByInput = "updatedAt_DESC"
          )

        type LikesOrderByInput string
        const (
          LikesOrderByInputIDAsc LikesOrderByInput = "id_ASC"
LikesOrderByInputIDDesc LikesOrderByInput = "id_DESC"
LikesOrderByInputCreatedAtAsc LikesOrderByInput = "createdAt_ASC"
LikesOrderByInputCreatedAtDesc LikesOrderByInput = "createdAt_DESC"
LikesOrderByInputUpdatedAtAsc LikesOrderByInput = "updatedAt_ASC"
LikesOrderByInputUpdatedAtDesc LikesOrderByInput = "updatedAt_DESC"
LikesOrderByInputQuantityAsc LikesOrderByInput = "quantity_ASC"
LikesOrderByInputQuantityDesc LikesOrderByInput = "quantity_DESC"
          )

        type UserOrderByInput string
        const (
          UserOrderByInputIDAsc UserOrderByInput = "id_ASC"
UserOrderByInputIDDesc UserOrderByInput = "id_DESC"
UserOrderByInputEmailAsc UserOrderByInput = "email_ASC"
UserOrderByInputEmailDesc UserOrderByInput = "email_DESC"
UserOrderByInputNameAsc UserOrderByInput = "name_ASC"
UserOrderByInputNameDesc UserOrderByInput = "name_DESC"
UserOrderByInputPasswordAsc UserOrderByInput = "password_ASC"
UserOrderByInputPasswordDesc UserOrderByInput = "password_DESC"
UserOrderByInputAgeAsc UserOrderByInput = "age_ASC"
UserOrderByInputAgeDesc UserOrderByInput = "age_DESC"
UserOrderByInputCreatedAtAsc UserOrderByInput = "createdAt_ASC"
UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

      type PostUpdateManyWithoutAuthorInput struct {
        Create []PostCreateWithoutAuthorInput `json:"create,omitempty"`
Delete []PostWhereUniqueInput `json:"delete,omitempty"`
Connect []PostWhereUniqueInput `json:"connect,omitempty"`
Set []PostWhereUniqueInput `json:"set,omitempty"`
Disconnect []PostWhereUniqueInput `json:"disconnect,omitempty"`
Update []PostUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
Upsert []PostUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
DeleteMany []PostScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []PostUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type LikesWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type PostCreateOneWithoutLikesInput struct {
        Create *PostCreateWithoutLikesInput `json:"create,omitempty"`
Connect *PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type UserUpdateWithoutPostsDataInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Age *int32 `json:"age,omitempty"`
Likes *LikesUpdateManyWithoutUserInput `json:"likes,omitempty"`
          }

      type PostCreateWithoutLikesInput struct {
        ID *string `json:"id,omitempty"`
Text string `json:"text"`
Author *UserCreateOneWithoutPostsInput `json:"author,omitempty"`
          }

      type LikesUpdateManyWithoutPostInput struct {
        Create []LikesCreateWithoutPostInput `json:"create,omitempty"`
Delete []LikesWhereUniqueInput `json:"delete,omitempty"`
Connect []LikesWhereUniqueInput `json:"connect,omitempty"`
Set []LikesWhereUniqueInput `json:"set,omitempty"`
Disconnect []LikesWhereUniqueInput `json:"disconnect,omitempty"`
Update []LikesUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
Upsert []LikesUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
DeleteMany []LikesScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []LikesUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type UserCreateOneWithoutPostsInput struct {
        Create *UserCreateWithoutPostsInput `json:"create,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikesWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
User *UserWhereInput `json:"user,omitempty"`
Post *PostWhereInput `json:"post,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
QuantityNot *int32 `json:"quantity_not,omitempty"`
QuantityIn []int32 `json:"quantity_in,omitempty"`
QuantityNotIn []int32 `json:"quantity_not_in,omitempty"`
QuantityLt *int32 `json:"quantity_lt,omitempty"`
QuantityLte *int32 `json:"quantity_lte,omitempty"`
QuantityGt *int32 `json:"quantity_gt,omitempty"`
QuantityGte *int32 `json:"quantity_gte,omitempty"`
And []LikesWhereInput `json:"AND,omitempty"`
Or []LikesWhereInput `json:"OR,omitempty"`
Not []LikesWhereInput `json:"NOT,omitempty"`
          }

      type UserCreateWithoutPostsInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Age int32 `json:"age"`
Likes *LikesCreateManyWithoutUserInput `json:"likes,omitempty"`
          }

      type PostSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *PostWhereInput `json:"node,omitempty"`
And []PostSubscriptionWhereInput `json:"AND,omitempty"`
Or []PostSubscriptionWhereInput `json:"OR,omitempty"`
Not []PostSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LikesCreateManyWithoutUserInput struct {
        Create []LikesCreateWithoutUserInput `json:"create,omitempty"`
Connect []LikesWhereUniqueInput `json:"connect,omitempty"`
          }

      type UserUpdateManyMutationInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Age *int32 `json:"age,omitempty"`
          }

      type LikesCreateWithoutUserInput struct {
        ID *string `json:"id,omitempty"`
Post *PostCreateOneWithoutLikesInput `json:"post,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
          }

      type UserCreateInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Age int32 `json:"age"`
Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
Likes *LikesCreateManyWithoutUserInput `json:"likes,omitempty"`
          }

      type LikesUpdateInput struct {
        User *UserUpdateOneWithoutLikesInput `json:"user,omitempty"`
Post *PostUpdateOneWithoutLikesInput `json:"post,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
          }

      type PostUpdateInput struct {
        Text *string `json:"text,omitempty"`
Author *UserUpdateOneWithoutPostsInput `json:"author,omitempty"`
Likes *LikesUpdateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type UserUpdateOneWithoutLikesInput struct {
        Create *UserCreateWithoutLikesInput `json:"create,omitempty"`
Update *UserUpdateWithoutLikesDataInput `json:"update,omitempty"`
Upsert *UserUpsertWithoutLikesInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostCreateInput struct {
        ID *string `json:"id,omitempty"`
Text string `json:"text"`
Author *UserCreateOneWithoutPostsInput `json:"author,omitempty"`
Likes *LikesCreateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type UserUpdateWithoutLikesDataInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Age *int32 `json:"age,omitempty"`
Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
          }

      type PostUpsertWithoutLikesInput struct {
        Update PostUpdateWithoutLikesDataInput `json:"update"`
Create PostCreateWithoutLikesInput `json:"create"`
          }

      type LikesUpdateManyWithoutUserInput struct {
        Create []LikesCreateWithoutUserInput `json:"create,omitempty"`
Delete []LikesWhereUniqueInput `json:"delete,omitempty"`
Connect []LikesWhereUniqueInput `json:"connect,omitempty"`
Set []LikesWhereUniqueInput `json:"set,omitempty"`
Disconnect []LikesWhereUniqueInput `json:"disconnect,omitempty"`
Update []LikesUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
Upsert []LikesUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
DeleteMany []LikesScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []LikesUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type UserUpsertWithoutPostsInput struct {
        Update UserUpdateWithoutPostsDataInput `json:"update"`
Create UserCreateWithoutPostsInput `json:"create"`
          }

      type PostUpdateWithWhereUniqueWithoutAuthorInput struct {
        Where PostWhereUniqueInput `json:"where"`
Data PostUpdateWithoutAuthorDataInput `json:"data"`
          }

      type LikesUpdateWithoutUserDataInput struct {
        Post *PostUpdateOneWithoutLikesInput `json:"post,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
          }

      type PostUpdateWithoutAuthorDataInput struct {
        Text *string `json:"text,omitempty"`
Likes *LikesUpdateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type UserCreateOneWithoutLikesInput struct {
        Create *UserCreateWithoutLikesInput `json:"create,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Text *string `json:"text,omitempty"`
TextNot *string `json:"text_not,omitempty"`
TextIn []string `json:"text_in,omitempty"`
TextNotIn []string `json:"text_not_in,omitempty"`
TextLt *string `json:"text_lt,omitempty"`
TextLte *string `json:"text_lte,omitempty"`
TextGt *string `json:"text_gt,omitempty"`
TextGte *string `json:"text_gte,omitempty"`
TextContains *string `json:"text_contains,omitempty"`
TextNotContains *string `json:"text_not_contains,omitempty"`
TextStartsWith *string `json:"text_starts_with,omitempty"`
TextNotStartsWith *string `json:"text_not_starts_with,omitempty"`
TextEndsWith *string `json:"text_ends_with,omitempty"`
TextNotEndsWith *string `json:"text_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Author *UserWhereInput `json:"author,omitempty"`
LikesEvery *LikesWhereInput `json:"likes_every,omitempty"`
LikesSome *LikesWhereInput `json:"likes_some,omitempty"`
LikesNone *LikesWhereInput `json:"likes_none,omitempty"`
And []PostWhereInput `json:"AND,omitempty"`
Or []PostWhereInput `json:"OR,omitempty"`
Not []PostWhereInput `json:"NOT,omitempty"`
          }

      type PostCreateManyWithoutAuthorInput struct {
        Create []PostCreateWithoutAuthorInput `json:"create,omitempty"`
Connect []PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikesUpdateWithWhereUniqueWithoutPostInput struct {
        Where LikesWhereUniqueInput `json:"where"`
Data LikesUpdateWithoutPostDataInput `json:"data"`
          }

      type LikesCreateManyWithoutPostInput struct {
        Create []LikesCreateWithoutPostInput `json:"create,omitempty"`
Connect []LikesWhereUniqueInput `json:"connect,omitempty"`
          }

      type LikesUpdateWithoutPostDataInput struct {
        User *UserUpdateOneWithoutLikesInput `json:"user,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
          }

      type UserWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Email *string `json:"email,omitempty"`
EmailNot *string `json:"email_not,omitempty"`
EmailIn []string `json:"email_in,omitempty"`
EmailNotIn []string `json:"email_not_in,omitempty"`
EmailLt *string `json:"email_lt,omitempty"`
EmailLte *string `json:"email_lte,omitempty"`
EmailGt *string `json:"email_gt,omitempty"`
EmailGte *string `json:"email_gte,omitempty"`
EmailContains *string `json:"email_contains,omitempty"`
EmailNotContains *string `json:"email_not_contains,omitempty"`
EmailStartsWith *string `json:"email_starts_with,omitempty"`
EmailNotStartsWith *string `json:"email_not_starts_with,omitempty"`
EmailEndsWith *string `json:"email_ends_with,omitempty"`
EmailNotEndsWith *string `json:"email_not_ends_with,omitempty"`
Name *string `json:"name,omitempty"`
NameNot *string `json:"name_not,omitempty"`
NameIn []string `json:"name_in,omitempty"`
NameNotIn []string `json:"name_not_in,omitempty"`
NameLt *string `json:"name_lt,omitempty"`
NameLte *string `json:"name_lte,omitempty"`
NameGt *string `json:"name_gt,omitempty"`
NameGte *string `json:"name_gte,omitempty"`
NameContains *string `json:"name_contains,omitempty"`
NameNotContains *string `json:"name_not_contains,omitempty"`
NameStartsWith *string `json:"name_starts_with,omitempty"`
NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`
NameEndsWith *string `json:"name_ends_with,omitempty"`
NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`
Password *string `json:"password,omitempty"`
PasswordNot *string `json:"password_not,omitempty"`
PasswordIn []string `json:"password_in,omitempty"`
PasswordNotIn []string `json:"password_not_in,omitempty"`
PasswordLt *string `json:"password_lt,omitempty"`
PasswordLte *string `json:"password_lte,omitempty"`
PasswordGt *string `json:"password_gt,omitempty"`
PasswordGte *string `json:"password_gte,omitempty"`
PasswordContains *string `json:"password_contains,omitempty"`
PasswordNotContains *string `json:"password_not_contains,omitempty"`
PasswordStartsWith *string `json:"password_starts_with,omitempty"`
PasswordNotStartsWith *string `json:"password_not_starts_with,omitempty"`
PasswordEndsWith *string `json:"password_ends_with,omitempty"`
PasswordNotEndsWith *string `json:"password_not_ends_with,omitempty"`
Age *int32 `json:"age,omitempty"`
AgeNot *int32 `json:"age_not,omitempty"`
AgeIn []int32 `json:"age_in,omitempty"`
AgeNotIn []int32 `json:"age_not_in,omitempty"`
AgeLt *int32 `json:"age_lt,omitempty"`
AgeLte *int32 `json:"age_lte,omitempty"`
AgeGt *int32 `json:"age_gt,omitempty"`
AgeGte *int32 `json:"age_gte,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
PostsEvery *PostWhereInput `json:"posts_every,omitempty"`
PostsSome *PostWhereInput `json:"posts_some,omitempty"`
PostsNone *PostWhereInput `json:"posts_none,omitempty"`
LikesEvery *LikesWhereInput `json:"likes_every,omitempty"`
LikesSome *LikesWhereInput `json:"likes_some,omitempty"`
LikesNone *LikesWhereInput `json:"likes_none,omitempty"`
And []UserWhereInput `json:"AND,omitempty"`
Or []UserWhereInput `json:"OR,omitempty"`
Not []UserWhereInput `json:"NOT,omitempty"`
          }

      type LikesUpsertWithWhereUniqueWithoutPostInput struct {
        Where LikesWhereUniqueInput `json:"where"`
Update LikesUpdateWithoutPostDataInput `json:"update"`
Create LikesCreateWithoutPostInput `json:"create"`
          }

      type LikesSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *LikesWhereInput `json:"node,omitempty"`
And []LikesSubscriptionWhereInput `json:"AND,omitempty"`
Or []LikesSubscriptionWhereInput `json:"OR,omitempty"`
Not []LikesSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LikesScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
QuantityNot *int32 `json:"quantity_not,omitempty"`
QuantityIn []int32 `json:"quantity_in,omitempty"`
QuantityNotIn []int32 `json:"quantity_not_in,omitempty"`
QuantityLt *int32 `json:"quantity_lt,omitempty"`
QuantityLte *int32 `json:"quantity_lte,omitempty"`
QuantityGt *int32 `json:"quantity_gt,omitempty"`
QuantityGte *int32 `json:"quantity_gte,omitempty"`
And []LikesScalarWhereInput `json:"AND,omitempty"`
Or []LikesScalarWhereInput `json:"OR,omitempty"`
Not []LikesScalarWhereInput `json:"NOT,omitempty"`
          }

      type PostUpdateManyMutationInput struct {
        Text *string `json:"text,omitempty"`
          }

      type LikesUpdateManyWithWhereNestedInput struct {
        Where LikesScalarWhereInput `json:"where"`
Data LikesUpdateManyDataInput `json:"data"`
          }

      type LikesUpdateManyMutationInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
          }

      type LikesUpdateManyDataInput struct {
        Quantity *int32 `json:"quantity,omitempty"`
          }

      type LikesUpsertWithWhereUniqueWithoutUserInput struct {
        Where LikesWhereUniqueInput `json:"where"`
Update LikesUpdateWithoutUserDataInput `json:"update"`
Create LikesCreateWithoutUserInput `json:"create"`
          }

      type PostUpsertWithWhereUniqueWithoutAuthorInput struct {
        Where PostWhereUniqueInput `json:"where"`
Update PostUpdateWithoutAuthorDataInput `json:"update"`
Create PostCreateWithoutAuthorInput `json:"create"`
          }

      type LikesCreateInput struct {
        ID *string `json:"id,omitempty"`
User *UserCreateOneWithoutLikesInput `json:"user,omitempty"`
Post *PostCreateOneWithoutLikesInput `json:"post,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
          }

      type PostScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Text *string `json:"text,omitempty"`
TextNot *string `json:"text_not,omitempty"`
TextIn []string `json:"text_in,omitempty"`
TextNotIn []string `json:"text_not_in,omitempty"`
TextLt *string `json:"text_lt,omitempty"`
TextLte *string `json:"text_lte,omitempty"`
TextGt *string `json:"text_gt,omitempty"`
TextGte *string `json:"text_gte,omitempty"`
TextContains *string `json:"text_contains,omitempty"`
TextNotContains *string `json:"text_not_contains,omitempty"`
TextStartsWith *string `json:"text_starts_with,omitempty"`
TextNotStartsWith *string `json:"text_not_starts_with,omitempty"`
TextEndsWith *string `json:"text_ends_with,omitempty"`
TextNotEndsWith *string `json:"text_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
And []PostScalarWhereInput `json:"AND,omitempty"`
Or []PostScalarWhereInput `json:"OR,omitempty"`
Not []PostScalarWhereInput `json:"NOT,omitempty"`
          }

      type PostCreateWithoutAuthorInput struct {
        ID *string `json:"id,omitempty"`
Text string `json:"text"`
Likes *LikesCreateManyWithoutPostInput `json:"likes,omitempty"`
          }

      type PostUpdateManyWithWhereNestedInput struct {
        Where PostScalarWhereInput `json:"where"`
Data PostUpdateManyDataInput `json:"data"`
          }

      type UserSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *UserWhereInput `json:"node,omitempty"`
And []UserSubscriptionWhereInput `json:"AND,omitempty"`
Or []UserSubscriptionWhereInput `json:"OR,omitempty"`
Not []UserSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type PostUpdateManyDataInput struct {
        Text *string `json:"text,omitempty"`
          }

      type PostWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type UserUpdateOneWithoutPostsInput struct {
        Create *UserCreateWithoutPostsInput `json:"create,omitempty"`
Update *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`
Upsert *UserUpsertWithoutPostsInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type PostUpdateWithoutLikesDataInput struct {
        Text *string `json:"text,omitempty"`
Author *UserUpdateOneWithoutPostsInput `json:"author,omitempty"`
          }

      type PostUpdateOneWithoutLikesInput struct {
        Create *PostCreateWithoutLikesInput `json:"create,omitempty"`
Update *PostUpdateWithoutLikesDataInput `json:"update,omitempty"`
Upsert *PostUpsertWithoutLikesInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *PostWhereUniqueInput `json:"connect,omitempty"`
          }

      type UserUpsertWithoutLikesInput struct {
        Update UserUpdateWithoutLikesDataInput `json:"update"`
Create UserCreateWithoutLikesInput `json:"create"`
          }

      type UserWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
Email *string `json:"email,omitempty"`
          }

      type UserUpdateInput struct {
        Email *string `json:"email,omitempty"`
Name *string `json:"name,omitempty"`
Password *string `json:"password,omitempty"`
Age *int32 `json:"age,omitempty"`
Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
Likes *LikesUpdateManyWithoutUserInput `json:"likes,omitempty"`
          }

      type LikesCreateWithoutPostInput struct {
        ID *string `json:"id,omitempty"`
User *UserCreateOneWithoutLikesInput `json:"user,omitempty"`
Quantity *int32 `json:"quantity,omitempty"`
          }

      type UserCreateWithoutLikesInput struct {
        ID *string `json:"id,omitempty"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Age int32 `json:"age"`
Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
          }

      type LikesUpdateWithWhereUniqueWithoutUserInput struct {
        Where LikesWhereUniqueInput `json:"where"`
Data LikesUpdateWithoutUserDataInput `json:"data"`
          }


        type UserPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
                  var v UserPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
            var v []UserPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserPreviousValuesFields = []string{"id", "email", "name", "password", "age", "createdAt"}

        type UserPreviousValues struct {
          ID string `json:"id"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Age int32 `json:"age"`
CreatedAt string `json:"createdAt"`
        }

        type LikesEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikesEdgeExec) Node() *LikesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Likes"},
                    "node",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikesExec{ret}
                }

          
                func (instance LikesEdgeExec) Exec(ctx context.Context) (*LikesEdge, error) {
                  var v LikesEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikesEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikesEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikesEdgeExecArray) Exec(ctx context.Context) ([]LikesEdge, error) {
            var v []LikesEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikesEdgeFields = []string{"cursor"}

        type LikesEdge struct {
          Node Likes `json:"node"`
Cursor string `json:"cursor"`
        }

        type PostSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostSubscriptionPayloadExec) Node() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "node",
                    []string{"id","text","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

                func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PostPreviousValues"},
                    "previousValues",
                    []string{"id","text","createdAt","updatedAt"})

                  return &PostPreviousValuesExec{ret}
                }

          
                func (instance PostSubscriptionPayloadExec) Exec(ctx context.Context) (*PostSubscriptionPayload, error) {
                  var v PostSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PostSubscriptionPayload, error) {
            var v []PostSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type PostSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *Post `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type UserConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "User"},
                      "node",
                      UserFields)

                    return &UserEdgeExecArray{nodes}
                  }

                  func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateUser"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &UserConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
            var v []UserConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserConnectionFields = []string{}

        type UserConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []UserEdge `json:"edges"`
        }

        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
                  var v PageInfo
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }


        type LikesConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikesConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *LikesConnectionExec) Edges() *LikesEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"LikesWhereInput", "LikesOrderByInput", "LikesEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "Likes"},
                      "node",
                      LikesFields)

                    return &LikesEdgeExecArray{nodes}
                  }

                  func (instance *LikesConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateLikes"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance LikesConnectionExec) Exec(ctx context.Context) (*LikesConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &LikesConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance LikesConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikesConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikesConnectionExecArray) Exec(ctx context.Context) ([]LikesConnection, error) {
            var v []LikesConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikesConnectionFields = []string{}

        type LikesConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []LikesEdge `json:"edges"`
        }


        type PostPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance PostPreviousValuesExec) Exec(ctx context.Context) (*PostPreviousValues, error) {
                  var v PostPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostPreviousValuesExecArray) Exec(ctx context.Context) ([]PostPreviousValues, error) {
            var v []PostPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostPreviousValuesFields = []string{"id", "text", "createdAt", "updatedAt"}

        type PostPreviousValues struct {
          ID string `json:"id"`
Text string `json:"text"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type PostConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *PostConnectionExec) Edges() *PostEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"PostWhereInput", "PostOrderByInput", "PostEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetOne(
                      edges,
                      nil,
                      [2]string{"", "Post"},
                      "node",
                      PostFields)

                    return &PostEdgeExecArray{nodes}
                  }

                  func (instance *PostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregatePost"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          
                func (instance PostConnectionExec) Exec(ctx context.Context) (*PostConnection, error) {
                  edges, err := instance.Edges().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  pageInfo, err := instance.PageInfo().Exec(ctx)
                  if err != nil {
                    return nil, err
                  }

                  return &PostConnection{
                    Edges:    edges,
                    PageInfo: *pageInfo,
                  }, nil
                }
              

          func (instance PostConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostConnectionExecArray) Exec(ctx context.Context) ([]PostConnection, error) {
            var v []PostConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostConnectionFields = []string{}

        type PostConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []PostEdge `json:"edges"`
        }

        type PostExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostExec) Author() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "author",
                    []string{"id","email","name","password","age","createdAt"})

                  return &UserExec{ret}
                }

                type LikesParamsExec struct {
                  Where *LikesWhereInput
OrderBy *LikesOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *PostExec) Likes(params *LikesParamsExec) *LikesExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"LikesWhereInput", "LikesOrderByInput", "Likes"},
                    "likes",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikesExecArray{ret}
                }

          
                func (instance PostExec) Exec(ctx context.Context) (*Post, error) {
                  var v Post
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostExecArray) Exec(ctx context.Context) ([]Post, error) {
            var v []Post
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostFields = []string{"id", "text", "createdAt", "updatedAt"}

        type Post struct {
          ID string `json:"id"`
Text string `json:"text"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type LikesPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          
                func (instance LikesPreviousValuesExec) Exec(ctx context.Context) (*LikesPreviousValues, error) {
                  var v LikesPreviousValues
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikesPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikesPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikesPreviousValuesExecArray) Exec(ctx context.Context) ([]LikesPreviousValues, error) {
            var v []LikesPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikesPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "quantity"}

        type LikesPreviousValues struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Quantity *int32 `json:"quantity,omitempty"`
        }

        type LikesSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikesSubscriptionPayloadExec) Node() *LikesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Likes"},
                    "node",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikesExec{ret}
                }

                func (instance *LikesSubscriptionPayloadExec) PreviousValues() *LikesPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LikesPreviousValues"},
                    "previousValues",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikesPreviousValuesExec{ret}
                }

          
                func (instance LikesSubscriptionPayloadExec) Exec(ctx context.Context) (*LikesSubscriptionPayload, error) {
                  var v LikesSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikesSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikesSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikesSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LikesSubscriptionPayload, error) {
            var v []LikesSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikesSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type LikesSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *Likes `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type LikesExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LikesExec) User() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "user",
                    []string{"id","email","name","password","age","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *LikesExec) Post() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "post",
                    []string{"id","text","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

          
                func (instance LikesExec) Exec(ctx context.Context) (*Likes, error) {
                  var v Likes
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance LikesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LikesExecArray struct {
            exec *prisma.Exec
          }

          func (instance LikesExecArray) Exec(ctx context.Context) ([]Likes, error) {
            var v []Likes
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var LikesFields = []string{"id", "createdAt", "updatedAt", "quantity"}

        type Likes struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Quantity *int32 `json:"quantity,omitempty"`
        }


        type UserSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","email","name","password","age","createdAt"})

                  return &UserExec{ret}
                }

                func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "UserPreviousValues"},
                    "previousValues",
                    []string{"id","email","name","password","age","createdAt"})

                  return &UserPreviousValuesExec{ret}
                }

          
                func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
                  var v UserSubscriptionPayload
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
            var v []UserSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

        type UserSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *User `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type PostEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PostEdgeExec) Node() *PostExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Post"},
                    "node",
                    []string{"id","text","createdAt","updatedAt"})

                  return &PostExec{ret}
                }

          
                func (instance PostEdgeExec) Exec(ctx context.Context) (*PostEdge, error) {
                  var v PostEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance PostEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PostEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance PostEdgeExecArray) Exec(ctx context.Context) ([]PostEdge, error) {
            var v []PostEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var PostEdgeFields = []string{"cursor"}

        type PostEdge struct {
          Node Post `json:"node"`
Cursor string `json:"cursor"`
        }

        type UserExec struct {
          exec *prisma.Exec
        }

        
                type PostsParamsExec struct {
                  Where *PostWhereInput
OrderBy *PostOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *UserExec) Posts(params *PostsParamsExec) *PostExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"PostWhereInput", "PostOrderByInput", "Post"},
                    "posts",
                    []string{"id","text","createdAt","updatedAt"})

                  return &PostExecArray{ret}
                }

                func (instance *UserExec) Likes(params *LikesParamsExec) *LikesExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"LikesWhereInput", "LikesOrderByInput", "Likes"},
                    "likes",
                    []string{"id","createdAt","updatedAt","quantity"})

                  return &LikesExecArray{ret}
                }

          
                func (instance UserExec) Exec(ctx context.Context) (*User, error) {
                  var v User
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
            var v []User
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserFields = []string{"id", "email", "name", "password", "age", "createdAt"}

        type User struct {
          ID string `json:"id"`
Email string `json:"email"`
Name string `json:"name"`
Password string `json:"password"`
Age int32 `json:"age"`
CreatedAt string `json:"createdAt"`
        }

        type UserEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserEdgeExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","email","name","password","age","createdAt"})

                  return &UserExec{ret}
                }

          
                func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
                  var v UserEdge
                  ok, err := instance.exec.Exec(ctx, &v)
                  if err != nil {
                    return nil, err
                  }
                  if !ok {
                    return nil, ErrNoResult
                  }
                  return &v, nil
                }
              

          func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
            var v []UserEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        var UserEdgeFields = []string{"cursor"}

        type UserEdge struct {
          Node User `json:"node"`
Cursor string `json:"cursor"`
        }






        